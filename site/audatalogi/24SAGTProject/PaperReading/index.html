
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="tinsir888">
      
      
        <link rel="canonical" href="https://tinsir888.codeberg.page/notes-mkdocs/site/audatalogi/24SAGTProject/PaperReading/">
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.21">
    
    
      
        <title>算法博弈论 三篇不同方向的论文阅读 - tinsir888's Study Notes</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.2a3383ac.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#possible-project-topics-of-algorithmic-game-theory" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="tinsir888&#39;s Study Notes" class="md-header__button md-logo" aria-label="tinsir888's Study Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            tinsir888's Study Notes
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              算法博弈论 三篇不同方向的论文阅读
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="tinsir888&#39;s Study Notes" class="md-nav__button md-logo" aria-label="tinsir888's Study Notes" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    tinsir888's Study Notes
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    CS@NKU
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            CS@NKU
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    感知技术与应用
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            感知技术与应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/PerceptionTechnology/Kapite1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 绪论
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/PerceptionTechnology/Kapite2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 传感器的性能与评价
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/PerceptionTechnology/Kapite3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 电传感原理与测量方法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/PerceptionTechnology/Kapite4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 常用物理效应与器件
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    数字信号处理
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            数字信号处理
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    课程概览
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 时域数字信号处理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 信号分类
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 再探时域数字信号处理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 数字信号
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 信号与系统
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章 离散时间傅里叶变换
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DigitalSignalProcessing/Kapitel8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章 频谱分析
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/DatabaseSystem/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    数据库
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    智能计算系统
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            智能计算系统
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 绪论
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 神经网络基础
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 深度学习
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 编程框架使用
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 编程框架机理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章 深度学习处理器原理
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章 深度学习处理器架构
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/AIComputingSystem/Kapitel8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第八章 智能编程语言
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    汇编与逆向
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            汇编与逆向
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    绪论
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 汇编语言基本概念
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 IA-32 处理器体系结构
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 汇编语言基础
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 数据传送与寻址
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 过程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章 PE 文件结构
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章 区块表、输入表和输出表
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第八章 静态逆向技术
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel9/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第九章 C 语言程序逆向分析
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/Assembler%26ReverseEngineering/Kapitel10/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第十章 软件保护技术
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    网络技术与应用
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            网络技术与应用
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 概述
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 以太网
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 交换与虚拟局域网
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 无线局域网组网技术
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 互联网与 IP 协议
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel6/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章 IP 数据报
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章 IP 地址与 ARP
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第八章 路由器与路由选择
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/NetworkTechnology/Kapitel9/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第九章 接入互联网
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_7" >
        
          
          <label class="md-nav__link" for="__nav_2_7" id="__nav_2_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    计算机体系结构
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_7">
            <span class="md-nav__icon md-icon"></span>
            计算机体系结构
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA1%E6%A6%82%E8%BF%B020210906/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 概述
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA2%E9%87%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%AF%84%E4%BC%B020210918/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 量化设计与评估
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA3%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%8420210927/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 指令集体系结构
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA4%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A120211011/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 存储层次
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA5%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%281%2920211018/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 流水线技术上
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA6%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF%282%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章 流水线技术下
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA7%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%80%A7%281%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章 指令级并行性上
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA8%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%80%A7%282%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第八章 指令级并行性下
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA9%E6%95%B0%E6%8D%AE%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%80%A7%281%29/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第九章 数据级并行性上
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA10%E6%95%B0%E6%8D%AE%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%80%A7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第十章 数据级并行性下
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA11%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%B9%B6%E8%A1%8C%E6%80%A7/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第十一章 线程级并行性
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerArchitecture/CA12%E4%BB%93%E5%BA%93%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第十二章 仓库级计算机
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_8" >
        
          
          <label class="md-nav__link" for="__nav_2_8" id="__nav_2_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    计算机网络
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_8">
            <span class="md-nav__icon md-icon"></span>
            计算机网络
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerNetwork/Kapitel0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    课程信息
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerNetwork/Kapitel1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 计算机网络概述
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerNetwork/Kapitel2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 应用层协议及网络编程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerNetwork/Kapitel3/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 传输层协议
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerNetwork/Kapitel4/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 网络层协议
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/ComputerNetwork/Kapitel5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 接口层原理与协议
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_9" >
        
          
          <label class="md-nav__link" for="__nav_2_9" id="__nav_2_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    强化学习
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_9">
            <span class="md-nav__icon md-icon"></span>
            强化学习
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel1-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第一章 强化学习简介
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel2-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第二章 马尔可夫决策过程
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel3-%E5%80%BC%E5%87%BD%E6%95%B0%E4%BC%B0%E8%AE%A1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第三章 值函数估计
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel4-%E6%97%A0%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第四章 无模型控制方法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel5-%E8%BF%91%E4%BC%BC%E9%80%BC%E8%BF%91%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第五章 近似逼近方法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel6-%E8%A7%84%E5%88%92%E4%B8%8E%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第六章 规划与学习
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel7-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%BB%B7%E5%80%BC%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第七章 深度强化学习价值方法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel8-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%AD%96%E7%95%A5%E6%96%B9%E6%B3%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第八章 深度强化学习策略方法
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../nkucs/handsonrl/Kapitel14-%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    第十四章 多智能体强化学习
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#algorithmic-game-theory" class="md-nav__link">
    <span class="md-ellipsis">
      Algorithmic Game Theory
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Algorithmic Game Theory">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mechanism-design-white_check_mark" class="md-nav__link">
    <span class="md-ellipsis">
      Mechanism Design :white_check_mark:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#games-and-price-of-anarchy" class="md-nav__link">
    <span class="md-ellipsis">
      Games and Price of Anarchy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#equilibrium-computation" class="md-nav__link">
    <span class="md-ellipsis">
      Equilibrium Computation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#computational-social-choice" class="md-nav__link">
    <span class="md-ellipsis">
      Computational Social Choice
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Computational Social Choice">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#voting-white_check_mark" class="md-nav__link">
    <span class="md-ellipsis">
      Voting​ :white_check_mark:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matching" class="md-nav__link">
    <span class="md-ellipsis">
      Matching
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fair-division-white_check_mark" class="md-nav__link">
    <span class="md-ellipsis">
      Fair Division :white_check_mark:
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<p>Iannis 给了三篇论文，三个方向。分别通读一下这三篇论文，看看什么主题比较感兴趣吧。</p>
<h1 id="possible-project-topics-of-algorithmic-game-theory">Possible Project Topics of Algorithmic Game Theory</h1>
<h2 id="algorithmic-game-theory">Algorithmic Game Theory</h2>
<h3 id="mechanism-design-white_check_mark">Mechanism Design :white_check_mark:</h3>
<ul>
<li>Auction Theory</li>
<li>Market Design</li>
<li>......</li>
</ul>
<p>The first paper is about <strong>Mechanism Design</strong> for Machine Learning/Statistical Tasks.</p>
<blockquote>
<p>简单来讲就是说，将提供训练集的个体视为智能体 Agent，在训练人工智能模型的时候，这些智能体有动机操纵提供的训练集数据来使得人工智能模型最终的输出有利于该智能体。而研究者的任务是研究如何设计一个机制来鼓励智能体提供真实的数据（no incentive to misreport）</p>
</blockquote>
<ul>
<li>Mean Estimation (2016 ICML)</li>
<li>Classification</li>
<li>Regression (Current)</li>
</ul>
<h3 id="games-and-price-of-anarchy">Games and Price of Anarchy</h3>
<ul>
<li>Price of Anarchy</li>
<li>Price of Stability</li>
</ul>
<h3 id="equilibrium-computation">Equilibrium Computation</h3>
<p>Didn't cover in the course.</p>
<h2 id="computational-social-choice">Computational Social Choice</h2>
<h3 id="voting-white_check_mark">Voting​ :white_check_mark:</h3>
<p>Didn't cover in the course.</p>
<p>The second paper is about <strong>Computational Social Choice</strong> for Federated learning</p>
<h3 id="matching">Matching</h3>
<ul>
<li>Stable Matching (Gale–Shapley algorithm)</li>
<li>Kidney-exchange</li>
</ul>
<h3 id="fair-division-white_check_mark">Fair Division :white_check_mark:</h3>
<p>Didn't cover in the course.</p>
<p>The third paper is about <strong>Fair Division</strong>. (Ιωάννης 在该方向上做了相当多的工作，2009-2023 current)</p>
<h1 id="mechanism-design-for-machine-learning">Mechanism Design for Machine Learning</h1>
<p><a href="https://arxiv.org/abs/1805.10693">Strategyproof Linear Regression in High Dimensions</a> by Chen et al, ACM Economics and Computation 2018</p>
<p><a href="https://en.wikipedia.org/wiki/Strategyproofness">Strategyproof</a></p>
<blockquote>
<p>说人话：就是占优策略激励相容 (Dominant Strategy Incentive Compatible abbr. DSIC)，向机制诚实报告就是最优策略 dominant strategy</p>
</blockquote>
<h2 id="abstract">Abstract</h2>
<p>Strategyproof mechanisms on Linear regression</p>
<p>Agents: single-peaked preferences</p>
<p>Ham Sandwich Theorem</p>
<p>This paper proposed: <em>Generalized Resistant Hyperplane</em> mechanisms.</p>
<h2 id="introduction">Introduction</h2>
<p>Motivation: Designing a Machine Learning algorithm that is <strong>robust to noise in training data</strong></p>
<p>Adversarial noise: sabotaging the algorithm.</p>
<blockquote>
<p>这一点有印象，本科期间了解过，在图像上有策略的增加一些肉眼很难分辨的对抗噪点就能欺骗视觉模型使得图像分类的结果出错。</p>
</blockquote>
<p>Training data: provided by <em>agents</em></p>
<p>Aligning the agents' incentives correctly → possible to obtain uncontaminated data</p>
<h3 id="scenario">Scenario</h3>
<p>Linear Regression i.e., fitting a hyperplane through given data.</p>
<p>Agents' incentive: to minimize their vertical distance from the output hyperplane.</p>
<p>Design: Strategyproof regression mechanisms without payments.</p>
<h3 id="proposed-model">Proposed Model</h3>
<p>Fitting a hyperplane through data points $(\mathbb x_i,y_i)$ for $\mathbb x_i\in\mathbb R^d;y_i\in\mathbb R;i=1,\cdots,n$.</p>
<p>$y_i$ is held only by agent $i$.</p>
<p>$\mathbb x_i$ is independent variables, public information.</p>
<p>Mechanism: elicits the private information of the agents, returns a hyperplane represented by vector $\beta=(\beta_1,\beta_0)\in\mathbb R^{d+1}$.</p>
<p>Residual for agent $i$: $r_i=y_i-\beta_1^T\mathbb x_i-\beta_0$</p>
<p>Agents wish to minimize $|r_i|$</p>
<p>Dekel et al: <strong>empirical risk minimization with $L_1$ loss</strong> ($L_1$-ERM) coupled with <strong>specific tie-breaking rule</strong> is group strategyproof.</p>
<blockquote>
<p>No coalition of agents can be weakly better off by misreporting.</p>
</blockquote>
<p>This paper: replacing the $L_1$ loss by a <strong>weighted $L_1$ loss</strong> and adding <strong>convex regularization</strong> to the <strong>risk function</strong> preserves group strategyproof.</p>
<p>Perote et al: 2-dimensional case, propose a wide family of strategyproof mechanisms, <em>clockwise repeated median</em> (CRM).</p>
<p>But this paper prove that it's wrong, giving 3 stricter conditions. CRM mechanism coincide with <em>resistant line mechanisms</em></p>
<h3 id="main-result">Main Result</h3>
<p>Generalizing CRM family to higher dimensions.</p>
<p>Introduce the family of <em>generalized resistant hyperplane</em> (GRH).</p>
<blockquote>
<p>In $d+1$ dimensions, GRH parametrized by $d+1$ subset of agents. </p>
</blockquote>
<p>Impartiality: group strategyproof.</p>
<blockquote>
<p>比 DSIC 更严苛：如果智能体相互之间串通，谎报都不能使得收益增加。</p>
</blockquote>
<p>Another desideratum except strategyproof: Good statistical efficiency.</p>
<p>Important: this paper establish a lower bound of $2$ on the approximation ratio of any strategyproof mechanism, which means that any mechanism that is even close to ordinary least squares regression must be manipulable.</p>
<h2 id="related-work">Related Work</h2>
<p>Research: 3 categories:</p>
<ol>
<li>Manipulable information</li>
</ol>
<p>Most papers assume: independent variables (feature vectors) - public; Dependent variables (labels) - private.</p>
<ul>
<li>
<p>Strategyproof classifiers / agents interest in a shared set of input points.</p>
</li>
<li>
<p>Constructing classifiers robust to agents strategically misreporting <em>feature vector</em>.</p>
<p>One-shot <a href="https://en.wikipedia.org/wiki/Stackelberg_competition">Stackelberg game</a></p>
</li>
<li>
<p>Goal of the agents :white_check_mark: (Exact one this paper discusses)</p>
</li>
<li>
<p>Motivated by privacy concerns: Tradeoff between accuracy and privacy</p>
</li>
<li>
<p>Agent want model make accurate assessment on their own sample, even if this reduce overall accuracy.</p>
</li>
<li>
<p>Use of payments and incentive guarantees</p>
</li>
<li>
<p>Monetary payment?</p>
</li>
<li>
<p>How strongly to guarantee truthful reporting</p>
<p>stronger strategyproofness VS. Bayes-Nash incentive compatibility.</p>
</li>
</ul>
<h2 id="model">Model</h2>
<p>(Omit Notation here)</p>
<p>Strategyproofness: Every single agent has no incentive to misreport its true value.</p>
<p><strong>Group Strategyproofness</strong>: Stronger than strategyproofness. No coalition of agents can simultaneously misreport in a way that: no agent in the coalition is strictly worse off and some agent in the coalition is strictly better off (with no regards to other agents' report value)</p>
<p>This paper does not consider weaker group strategyproofness, as mechanism proposed is able to satisfy stronger one.</p>
<h2 id="families-of-strategyproof-mechanisms">Families of Strategyproof Mechanisms</h2>
<h3 id="empirical-risk-minimization-with-the-l_1-loss">Empirical Risk Minimization with the $L_1$ Loss</h3>
<p>When dimension $d=0$ i.e., $\mathbb x_i=\mathbb x_j(\forall i,j\in N)$. Choosing the median of the reported values achieves group strategyproofness.</p>
<p>Median minimize $L_1$ loss: $\arg\min_{y\in\mathbb R}\sum_{i=1}^n|y-y_i|$.</p>
<p>This can be generalized into higher dimension while maintaining group strategy proof (Dekel et al)</p>
<p>This paper proposes <strong>Generalized $L_1$-ERM</strong>, which is also group strategyproof.</p>
<blockquote>
<p>Weighted $L_1$ loss, the loss of each agent $i$ is multiplied by a weight $w_i^{\mathbb x}$.</p>
<p>adding a convex regularizer $h:\mathcal F\rarr R$</p>
</blockquote>
<p>Advantage of Generalized $L_1$-ERM:</p>
<ol>
<li>Eliminating tie-breaking step if risk function guaranteed to have a unique minimizer (To achieve this by adding strictly convex regularizer).</li>
<li>It covers all generalized medians while $L_1$-ERM reduces to a specific mechanism.</li>
</ol>
<p><em>quantile regression</em> mechanisms
$$
\hat R_q(f,\mathcal D)=\sum_{y_i\ge f(\mathbb x_i)}q\cdot|y_i-f(\mathbb x_i)|+\sum_{y_i\lt f(\mathbb x_i)}(1-q)\cdot|y_i-f(\mathbb x_i)|
$$
<strong>Not remain strategyproof in higher dimension</strong>.</p>
<h3 id="generalized-resistant-hyperplane-mechanisms">Generalized Resistant Hyperplane Mechanisms</h3>
<p>Extending family of <em>resistant line</em> mechanisms.</p>
<h4 id="clockwise-repeated-median-mechanisms">Clockwise Repeated Median Mechanisms</h4>
<p>Perote et al.</p>
<p>Only defined for the special case of simple linear regression.</p>
<p>Need to assume that set of points is <strong>admissible</strong></p>
<blockquote>
<p>Admissible set is a collection of data points $\mathcal D=(x_i,y_i)_{i\in N}$ that $x_i\neq x_j\forall i,j\in N$</p>
</blockquote>
<p>Step:</p>
<ol>
<li>Divide agent into two subsets $S,S'$.</li>
<li>Compute the median <em>clockwise angle</em> (CWA)</li>
<li>For each point in $S$, choose $i^*\in S$ whose median CWA is the median of median CWAs from all points in $S$.</li>
<li>If median CWA from $i^<em>$ is towards point $j^</em>\in S'$, the mechanism returns the straight line passing through points $i^<em>$ and $j^</em>$.</li>
</ol>
<p>CWA</p>
<blockquote>
<p>From $(x_i,y_i)$ to $(x_j,y_j)$, CWA is
$$
\text{CWA}((x_i,y_i),(x_j,y_j))=\pi+\text{sign}(x_j-x_i)\cdot\frac{\pi}{2}+\text{sign}(\frac{y_j-y_i}{x_j-x_i})|\arctan(\frac{y_j-y_i}{x_j-x_i})|\
\text{sign}(x)=\begin{cases}
-1,x\lt0\
0,x=0\
1,x\gt0
\end{cases}
$$</p>
</blockquote>
<p>Directing angle</p>
<blockquote>
<p>$$
\text{DA}(S,S')=\text{med}<em>{i\in S}\text{med}</em>{j\in S':j\neq i}\text{CWA}((x_i,y_i),(x_j,y_j))
$$</p>
</blockquote>
<p>Mechanism returns the line $\beta=(\beta_1,\beta_0)$ s.t.
$$
\beta_1=\tan[\text{DA}(S,S')-\pi-\frac{\pi}{2}\cdot\text{sign}(\text{DA}(S,S')-\pi)]\
\beta_0=\text{med}_{i\in S}(y_i-\beta\cdot x_i)
$$
But this paper provides two counterexamples showing that $(S,S')$-CRM mechanisms (under Perote's loose restrict) violate strategyproofness.</p>
<p>This paper looks for a subset of the CRM mechanisms to establish group strategyproofness. (impose more restrictive conditions)</p>
<p>Separable Sets of Point in a Plane</p>
<blockquote>
<p>In this paper definition is two sets can be separated by a vertical line.</p>
</blockquote>
<p>$(S,S')$-CRM is group strategyproof if one of the following conditions holds</p>
<ol>
<li>$S=S'$.</li>
<li>$S$ and $S'$ are separable.</li>
<li>$S\cap S'=\empty$ and $\min(|S|,|S'|)=1$. (dictatorship)</li>
</ol>
<h4 id="generalized-resistant-line-mechanisms-on-a-plane">Generalized Resistant Line Mechanisms on a Plane</h4>
<p>This paper introduces a novel family of group strategyproof mechanisms.</p>
<p>Start from: <em>Resistant Line</em> mechanisms</p>
<blockquote>
<p>3 separable subset $L,M,R$. A line $\beta$ given by
$$
\text{med}<em>{i\in L}y_i-\beta_1x_i-\beta_0=\text{med}</em>{i\in R}y_i-\beta_1x_i-\beta_0=0
$$
Making median of residuals in $L$ and $R$ zero.</p>
</blockquote>
<p>Yielding $(L,R)$-CRM mechanism
$$
\beta_1=\text{med}<em>{i\in L}\text{med}</em>{j\in R}\frac{y_j-y_i}{x_j-x_i}\
\beta_0=\text{med}<em>{i\in L}y_i-\beta_1x_i=\text{med}</em>{j\in R}y_j-\beta_1x_j
$$
Brown-Mood mechanism: $L$ and $R$ are two half, $M$ is empty.</p>
<p>Tukey mechanism: $L,M,R$ each contains $1\over3$ points.</p>
<p>This paper: instead of making the <em>median</em> residuals from $S$ and $S'$ zero, making the k-th smallest residual in $S$ and $k'$-th smallest residual in $S'$ zero, for fixed $k\in[|S|]$ and $k'\in[|S'|]$.</p>
<p><strong>Generalized Resistant Line Mechanisms</strong> (GRL)
$$
\min_{i\in S}^ky_i-\beta_1x_i-\beta_0=\min_{j\in S'}^{k'} y_j-\beta_1x_j-\beta_0=0
$$
Theorem: <em>$(S,S',k,k')$-generalized resistant line mechanism</em> is <strong>group strategyproof</strong>.</p>
<p>Noted: GRL is a generalized resistant mechanism version of $(S,S')$-CRM mechanism.</p>
<h4 id="generalized-resistant-hyperplane-mechanisms-in-high-dimensions">Generalized Resistant Hyperplane Mechanisms in High Dimensions</h4>
<p>In $d+1$ dimension, take $d+1$ separable subsets of data points. Return regression hyperplane with makes prescribed percentiles of residuals in each set zero.</p>
<p>How to generalize to higher dimension? Using <strong>Ham Sandwich Theorem</strong>.</p>
<blockquote>
<p>A $d$-dimension hyperplane $H$ can "bisect" a $d+1$ hyperspace.</p>
</blockquote>
<p>Well separable aka <em>affinely independent sets</em></p>
<blockquote>
<p>Given $t\in[k+1]$, finite sets $S_1,\cdots,S_t$ of points in $\mathbb R^k$ are called <em>well separable</em> if for all disjoint $I,J\subseteq[t]$, there exists a hyperplane $H$ s.t. $S_i\sub H^+\diagdown H$ for each $i\in I$ and $S_j\sub H^-\diagdown H$ for each $j\in J$, i.e. $H$ separates $\cup_{i\in I}S_i$ from $\cup_{j\in J}S_j$ by putting them in different <em>open</em> half-spaces.</p>
</blockquote>
<p>:warning: Due to my shortage of (discrete) mathematics knowledge, hereinafter only put key words.</p>
<p>Weak General Position</p>
<p>Publicly Separable Sets of Agents</p>
<p>Generalized Resistant Hyperplane (GRH) Mechanism</p>
<p>Hyperplane Comparison Lemma</p>
<p>:sob: Too many lemmas, propositions and theorem.</p>
<p><strong>Main contribution</strong> of this paper:</p>
<p><strong>Every generalized resistant hyperplane mechanism is group strategyproof.</strong></p>
<h3 id="strategyproofness-versus-group-strategyproofness">Strategyproofness Versus Group Strategyproofness</h3>
<p>For $d=0$ all strategyproof mechanisms are group strategyproof. </p>
<p>Is it still true that all strategyproof mechanisms for linear regression are also group strategyproof? No!</p>
<p>Impartial Mechanism</p>
<blockquote>
<p>A mechanism $M$ is called <em>impartial</em> if the outcome for each agent is independent of the agent's report.</p>
</blockquote>
<p>Propositions and theorems...</p>
<h2 id="characterizing-strategyproof-mechanisms">Characterizing Strategyproof Mechanisms</h2>
<p>Locally Constant Function</p>
<blockquote>
<p>$$
\exist\epsilon\gt0,\forall x'\in[x-\epsilon,x+\epsilon],f(x')=f(x)
$$</p>
</blockquote>
<p>In one-dimensional setting, a mechanism elicits agents report $\pi(y)$ ($y$ is private true valuation) is strategyproof iff:</p>
<ol>
<li>There exist constant $\alpha^1,\alpha^2\in\overline{\mathbb{R}}\triangleq\mathbb R\cup{-\infty,+\infty}$</li>
<li>$\pi$ is continuous, for every $y\in\mathbb R$, either $\pi(y)=y$ or $\pi$ is locally constant at $y$.</li>
</ol>
<p>For higher dimension, the conditions are similar. (median and locally constant)</p>
<h2 id="efficiency-of-strategyproof-mechanisms">Efficiency of Strategyproof Mechanisms</h2>
<p>OLS (ordinary least square) aka RSS (residual sum of squares)</p>
<p>Gauss-Markov Theorem: justification for OLS</p>
<p>OLS is not strategyproof.</p>
<p>Efficiency</p>
<blockquote>
<p>Given $\mathbb x$m the mechanism $M^{\mathbb x}$ for linear regression is $c$-efficient if for every $\mathcal D=(\mathbb x_i,y_i)<em>{i\in N}$, we have $\text{RSS}(\mathcal D,M^{\mathbb x}(\mathbb y))\le c\cdot\inf</em>\beta\text{RSS}(\mathcal D,\beta)$.</p>
</blockquote>
<p>No strategyproof mechanism that is close to OLS can be strategyproof. (Proof omitted)</p>
<h2 id="discussion">Discussion</h2>
<p>Open question leaves:</p>
<p>How to find a constructive characterization of all strategyproof or group strategyproof mechanisms for linear regression.</p>
<p>$L_1$-ERM is $n$-efficient, does there exist a more efficient strategyproof mechanism?</p>
<p>Analysis efficiency in a stochastic setting: What if data points are drawn from a underlying distribution?</p>
<p>Further research on "phantom"?</p>
<p>Different game setting?</p>
<h1 id="computational-social-choice-for-federated-learning">Computational Social Choice for Federated Learning</h1>
<p><a href="https://arxiv.org/abs/2211.02091">Fairness in Federated Learning via Core-Stability</a> by Bhaskar et al. NeurIPS 2022</p>
<p><a href="https://en.wikipedia.org/wiki/Federated_learning">Federated learning</a></p>
<blockquote>
<p>简单来说，联邦学习就是在多个拥有本地数据样本的分布式边缘设备或服务器上训练人工智能模型，仅上传模型参数这种不敏感的数据到中心服务器中。会假定所有分布式的数据都是同分布的。训练过程是去中心化的。好处是保护数据隐私、数据安全等。</p>
<p>MIT Press 的 NeurIPS 人工智能顶会</p>
</blockquote>
<h2 id="abstract_1">Abstract</h2>
<p>We care about fairness. It is unfair for agents with high quality data to sacrifice their performance due to other agents with low quality data.</p>
<p>Currently: <em>egalitarian and weighted equity-based</em> fairness measures suffer from the above pitfall.</p>
<p>This paper: model the task of learning a shared predictor in the federated setting as a <em>fair public decision making</em> problem.</p>
<p><em>core-stable fairness</em>:</p>
<blockquote>
<p>Given $N$ agents, there is no subset of agents $S$ that can benefit significantly by forming a coalition among themselves based on their utilities.</p>
</blockquote>
<p>Core-stable predictors are robust to low quality local data</p>
<p><em>Proportionality</em></p>
<blockquote>
<p>each agent gets at least $\frac{1}{n}$ fraction of the best utility that she can get from any predictor.</p>
</blockquote>
<p><em><a href="https://en.wikipedia.org/wiki/Pareto_efficiency">Pareto-optimality</a></em></p>
<blockquote>
<p>There exists no model that can increase the utility of an agent without decreasing the utility of another.</p>
</blockquote>
<p>This paper: propose an efficient federated learning protocol <strong>CoreFed</strong> to optimize a core stable predictor.</p>
<p>Kakutani's fixed point theorem</p>
<h2 id="introduction_1">Introduction</h2>
<h3 id="background">Background</h3>
<p>Federated Learning (abbr. FL)</p>
<ul>
<li>
<p>utilize valuable data scatter in different organizations.</p>
</li>
<li>
<p>Challenge: Heterogenity in local data distributions. To ensure a fair performance of classifier across all local data distributions.</p>
</li>
</ul>
<p>Questions this paper asked: Jointly optimizing a certralized model with fairness guarantees regarding the heterogeneity of local agents. Defining such fairness s.t. no agents intend to form an coalition with a subset of agents. Finding a federated learning protocol to ensure such fairness.</p>
<p>Federated learning can be cast into <em>public decision making</em></p>
<blockquote>
<p>All agents derive respective utilities from a common global decision.</p>
<p>New goal: make this global decision fairly.</p>
</blockquote>
<p>Fundamental fairness meaures: <a href="https://en.wikipedia.org/wiki/Core_(game_theory)">core-stability</a>.</p>
<blockquote>
<p>An outcome is considered "core-stable" if, once a coalition is formed and an outcome is achieved, no subgroup of that coalition has an incentive to break away and form a new coalition to achieve a more favorable outcome for themselves.</p>
<p>A globally trained model is core stable if there are no blocking coalitions.</p>
</blockquote>
<p>2 commonly used fairness notions</p>
<ol>
<li>Egalitarian fairness</li>
</ol>
<p>Aims to maximize the utility of the least happy agent</p>
<ol>
<li>Proportional fairness aka weighted equity based fairness</li>
</ol>
<p>Ratios of the losses of any pair of the agents to be proportional to the size of their respective datasets.</p>
<p>This paper points out that both notions are vulnerable.</p>
<blockquote>
<p>Unfair to the other agents as both may reduce loss incurred by the noisy-agent, thereby biasing the learning.</p>
</blockquote>
<h3 id="contribution-of-this-paper">Contribution of This Paper</h3>
<p>Defining the core-stable fairness in FL.</p>
<ul>
<li>
<p>Modeling agents' utility functions to caputre their learning loss error.</p>
</li>
<li>
<p>$N$ local agents, protocol $P$, aggregated model $f$. $f$ achieves core-stability if there are no coalition $S$ of agents that could benefit significantly by training a model with only their data.</p>
</li>
</ul>
<p>i.e., no agent has the incentive to deviate from curret group and thereby obtain proportionally better aggregate utility from the final trained model.</p>
<p>就是说，在这一大群智能体中，没有任何一个真子集的智能体有动机去只用自己的数据训练模型。用所有人的数据训练比用这个真子集的数据训练效果更好。</p>
<p>Such model $f$ ensures:</p>
<ul>
<li>Proportionality: each agent gets $\frac{1}{n}$ times their best possible utility.</li>
<li>
<p>Pareto-optimality</p>
</li>
<li>
<p>Core-stability is popular but rare-to-exist. Learning errorrs are innately non-linear and highly complex.</p>
</li>
</ul>
<p>Contribution of this paper:</p>
<ol>
<li>Extending core-stability from AGT to fairness in FL.</li>
</ol>
<p>fixed point formulation</p>
<ol>
<li><strong>CoreFed</strong>: An Effective federated learning protocol which optimizes the final model by <strong>maximizing the protocol of agents' utilities</strong>.</li>
</ol>
<p>Whenever underlying utility functions are <strong>concave</strong>.</p>
<ol>
<li>Proving that CoreFed works in linear regression and logistic regression (utility functions are convex).</li>
</ol>
<p>For non-convex utility function (Smooth DNN), approximately core-stable.</p>
<ol>
<li>Extending core-stability into weighted core-stability. Showing that weighted core-stable model is weighted proportional and Pareto-optimal.</li>
</ol>
<p>CoreFed → weighted CoreFed</p>
<ol>
<li>Experiments on 3 datasets, CoreFed achieves the core-stable fairness, while maintaining similar utility with the standard FedAvg protocol.</li>
</ol>
<h2 id="related-work_1">Related Work</h2>
<h3 id="fairness-in-social-choice">Fairness in Social Choice</h3>
<p>Proportionality</p>
<blockquote>
<p>Every agent receives their propotional share of the best outcome. $\frac{1}{n}\times$ best utility themselves.</p>
</blockquote>
<p>Envy-freeness</p>
<blockquote>
<p>Divide a set of items among agents fairly.</p>
<p>No agent prefers the bundle of the other agent to her own. In public decision making this is impossible. Replaced by core-stability.</p>
<p>Equitability: every agent should be equally happy.</p>
<p>Relaxations of equitability: envy-freeness, proportionality.</p>
</blockquote>
<h3 id="fairness-in-federated-learning">Fairness in Federated Learning</h3>
<ul>
<li>
<p>Establishing fairness at the agent selection phase.</p>
</li>
<li>
<p>Fairness while training the global model s.t. no discrimination against protected groups.</p>
</li>
</ul>
<p>e.g. Egalitarian fairness</p>
<ul>
<li>Considering fairness by evaluating contribution of the agents towards training the joint model.</li>
</ul>
<p>e.g. weighted equity fairness</p>
<ul>
<li>Significance to the agents based on <a href="https://en.wikipedia.org/wiki/Shapley_value">Shapley values</a>.</li>
</ul>
<h2 id="core-stability-in-federated-learning">Core-Stability in Federated Learning</h2>
<h3 id="problem-setup">Problem Setup</h3>
<p>Model: A function mapping from $\mathcal X\in\mathbb R^d$ to $\mathcal Y\in\mathbb R$.</p>
<p>Regression or binary classification.</p>
<p>Such mapping:
$$
\mathcal F={f_\theta|\theta\in P\subseteq\mathbb R^d}\
f_\theta:\mathbb R^d\rarr\mathbb R
$$
s.t. for data sample $(x,y)$ drawn from the distribution $\mathcal P$, $f_\theta(x)\approx y$.</p>
<p>$\theta$ is called predictor for the model.</p>
<h4 id="utility-functions-of-agents">Utility Functions of Agents</h4>
<p>Quality of $\theta$ is measured by the expected loss over the data distribution $\mathcal P$, i.e., $\mathbb E_{(x,y)\sim\mathcal P}l(f_\theta(x),y)$.</p>
<p>$l(\cdot,\cdot)$ is a predefined loss function. Training process minimize expected loss, attaining $\theta^*=\arg\min_{\theta\in P}\mathbb E_{(x,y)\sim\mathcal P}l(f_\theta(x),y)$.</p>
<p>Utility function of a group for a predictor $\theta$:
$$
u(\theta)=M-\mathbb E_{(x,y)\sim\mathcal P}l(f_\theta(x),y)
$$
where $M$ is a constant more than $1+\epsilon$ times the loss incurred from the worst predictor for agent $i$, i.e.,
$$
M\ge(1+\epsilon)\sup_{\theta\in P,(x,y)\in\mathcal X\times\mathcal Y}l(f_\theta(x),y)\
0&lt;\epsilon\lt\lt10^{-5}
$$
Observation: $u(\theta)\in[M\epsilon,M(1+\epsilon)]$.</p>
<h4 id="federated-leaerning-and-fairness">Federated Leaerning and Fairness</h4>
<p>$n$ groups. Each group $i$ has their loss function $l_i(\cdot)$ and correspondingly a utility function $u_i(\cdot)$ for each $\theta\in P$.</p>
<p>Definition of <strong>core-stability</strong>:</p>
<blockquote>
<p>A prediction $\theta\in P$ is called core-stability if there exists no other $\theta'\in P$, and no subset $S$ of agents, s.t. $\frac{|S|}{n}u_i(\theta')\ge u_i(\theta)\forall i\in S$, with at least one strict inequality.</p>
<p>No subset coalition can give agent better utility.</p>
<p>This ensures that all agent benefit at least $\frac{1}{n}$ of its best possible utility. (Proportionality)</p>
</blockquote>
<p>Definition of <strong>proportionality</strong>:</p>
<blockquote>
<p>A predictor $\theta\in P$ is called proportional iff $\forall\theta'\in P$, we have $u_i(\theta)\ge\frac{u_i(\theta')}{n}$  $(\forall i\in[n])$.</p>
<p>No predictor that can increase theutility of some agent without decreasing the utility of another. (Pareto-optimality)</p>
</blockquote>
<p>Definition of <strong>Pareto-optimality</strong></p>
<blockquote>
<p>A prediction $\theta\in P$ is Pareto-optimal iff there exists no other $\theta'\in P$ s.t. $u_i(\theta')\ge u_i(\theta)$ for all $i\in[n]$ with at least one strict inequality.</p>
</blockquote>
<h4 id="advantages-of-core-stability">Advantages of Core-Stability</h4>
<p>Robust to low local data qualities of some agents.</p>
<p>Scale-invarance: Scaling the utility of any single agent does not alter the core-stable allocation.</p>
<h3 id="existence-of-core-stability-in-federated-learning">Existence of Core-Stability in Federated Learning</h3>
<p>Conditions:</p>
<ol>
<li>
<p>The utility function is continuous.</p>
</li>
<li>
<p>The set of maximizers of any conical combination of utility functions is convex.</p>
</li>
</ol>
<blockquote>
<p>Conical combination:  a linear combination where the coefficients are non-negative.</p>
</blockquote>
<p>2 conditions together with Kakutani's Fixed Point Theorem (角谷不动点定理), we can prove the existence of core-stabiltiy in FL.</p>
<h3 id="computation-of-a-core-stable-predictor-when-utility-functions-are-concave">Computation of a Core-Stable Predictor When Utility Functions are Concave</h3>
<p>Any predictor that maximizes the product of utilities of the agents, i.e., $\arg\max_{\theta\in P}\prod_{i\in[n]}u_i(\theta)$ is core-stable.</p>
<p>Convex program:
$$
\text{maximize }\mathcal L(\theta)=\sum_{i\in[n]}\log(u_i(\theta))\
\text{subject to }\theta\in P
$$
Theorem: if $u_i(\cdot)$ is concave for all $i\in[n]$, then any predictor $\theta^*$ that maximizes the convex program is core-stable. (Proof omitted)</p>
<p>Tightness of Guarantees: core-stability is tight.</p>
<h4 id="corefed">CoreFed</h4>
<p>For non-convex losses such as DNNs, applying gradient descent to maximize the objective.</p>
<p>$n$ finite samples ${x_i,y_i}_{i\in[n]}$ drawn from data distribution $\mathcal P$. Empirical distribution $\hat{\mathcal P}_n$.</p>
<p>Gradient descent:
$$
\nabla_\theta\mathcal L(\theta)=\sum_{i\in[n]}\frac{\nabla_\theta u_i(\theta)}{u_i(\theta)}=\sum_{i\in[n]}\frac{-\nabla_\theta\mathbb E_{(x,y)\sim\hat{\mathcal P}<em>n^{(i)}}l(f</em>\theta(x),y)}{M_i-\mathbb E_{(x,y)\sim\hat{\mathcal P}<em>n^{(i)}}l(f</em>\theta(x),y)}
$$
CoreFed: the model updates are weighted then aggregated at each iteration. (formular omitted here)</p>
<h3 id="core-stability-in-linear-regression-and-classification-with-logistic-regression">Core-Stability in Linear Regression and Classification with Logistic Regression</h3>
<p>This paper take linear regression and classification with logistic regression as example.</p>
<p>Since concavety of utility function in these scenarios are satisfied.</p>
<p>CoreFed can determin core-stable predictor in a federated learning setting training <strong>linear regression</strong> and <strong>logistic regression (classification)</strong>.</p>
<h3 id="approximate-core-stability-in-deep-nerual-networks">Approximate Core-Stability in Deep Nerual Networks</h3>
<p>Relaxed local core-stability we can attain for approximately first-order converged predictor.</p>
<p>:sob: very complex theorem for pseudo core stable predictor. (mere a mention here)</p>
<h3 id="weighted-core-stability">Weighted Core-Stability</h3>
<p>For each agent $i$, if we assign weight $w_i$, indicating the desired bias of the final trained model towards agent $i$. With subtle modifications, we can show the existence of a weighted core-stable predictor.</p>
<p>Weight Core-Stability</p>
<blockquote>
<p>Given a weight vector $w=(w_1,\cdots,w_n)$, a predictor $\theta\in P$, is weighted core-stable iff there exists no other predictor $\theta'\in P$ and a subset of agent $S\subseteq[n]$ s.t. 
$$
\frac{\sum_{j\in S}w_j}{\sum_{j\in[n]}w_j}\cdot u_i(\theta')\ge u_i(\theta)\text{ for all }i\in S
$$
with at least one strict inequality.</p>
</blockquote>
<h2 id="experiment">Experiment</h2>
<p>This paper evaluates CoreFed VS. FedAvg on Adult, MNIST, CIFAR-10 on linear model and deep neural network.</p>
<h3 id="experiment-results">Experiment Results</h3>
<p>CoreFed achieves the core-stable fairness through comparison with FedAvg on different datasets and settings.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Introducing a new notion of fairness in federated learning,</p>
<p>More resilient to noisy data from certain clients.</p>
<h1 id="fair-division">Fair Division</h1>
<p><a href="https://arxiv.org/abs/2208.08782">Fair Division of Indivisible Goods: Recent Progress and Open Questions</a> by Georgios et al, journal of Artificial Intelligence 2023</p>
<blockquote>
<p>这是一篇文献综述 literature review。爱思唯尔 AIJ，CCF A，顶刊属于是。</p>
<p>这篇综述看完了，太爽了。感觉自己还是对公平分配感兴趣。Dive into 进去可能会有一些收获。</p>
</blockquote>
<p>After reading , I drew a <a href="https://tinsir888.github.io/pdffile/FairDivisionMindmap.pdf">mindmap</a> about this paper.</p>
<h2 id="abstract_2">Abstract</h2>
<p>Fair division: Allocating resources to individuals in a <em>fair</em> manner.</p>
<p>Focus on <strong>indivisible</strong> case. Fairness notion:</p>
<ul>
<li>Envy-freeness</li>
<li>Proportional</li>
</ul>
<p>Relaxation of these notion:</p>
<ul>
<li>Maximin share fairness (MMS)</li>
<li>Envy-freeness up to any good (EFX)</li>
</ul>
<p>This paper: General review of recent progress for</p>
<ul>
<li>Different ways to relax fairness notions</li>
<li>Common algorithm design techniques</li>
<li>Interesting question for further research</li>
</ul>
<h2 id="introduction_2">Introduction</h2>
<p>Fair division: Fairly partitioning or allocating a set of resources to people with diverse and heterogeneous preferences over these resources.</p>
<p>Most classic work: Fair division of <strong>infinitely divisible</strong> resources.</p>
<p>Fairness means:</p>
<ol>
<li>
<p>Proportionality</p>
</li>
<li>
<p>Envy-freeness</p>
</li>
</ol>
<p>Envy-free allocation of divisible resources can always be found in a finite number of steps.</p>
<p>For <strong>indivisible</strong> resources, aka <em>discrete fair division</em>. More challenging.</p>
<ul>
<li>No reasonable fair solution can be guaranteed in some cases: a single valuable item.</li>
<li>Sometimes we need relaxations of envy-freeness and proportionality.</li>
</ul>
<p>Relaxations</p>
<ol>
<li>envy-freeness up to one good (EF1)</li>
<li>envy-freeness up to any good (EFX)</li>
<li>maximin share fairness (MMS)</li>
</ol>
<p>Road map of this paper:</p>
<ol>
<li>Introduction to the problem of discrete fair division</li>
<li>Results on EF1</li>
<li>Results on EFX</li>
<li>Results on MMS</li>
<li>Other notable fairness notions for the main setting</li>
<li>Efficiency and truthfulness</li>
<li>Other setting e.g. limited information, general valuations, randomness ...</li>
</ol>
<h2 id="the-setting">The Setting</h2>
<p>Set $N$ of $n$ agents</p>
<p>Set $M$ of $m$ goods (can't be divided or shared)</p>
<p>Agent $i\in N$ is equipped with a valuation function $v_i:2^M\rightarrow\mathbb R_{\ge0}$, which assigns a non-negative real number to each possible subset of items and is <em>normalized</em> and <em>monotone</em>, i.e., $v_i(\emptyset)=0$ and $v_i(S)\le v_i(T)\forall S\subseteq T\subseteq M$.</p>
<p>Focus on valuation function of each agent is assumed to be <em>additive</em>. $v_i(S)=\sum_{g\in S}v_i(g)\forall S\subseteq M$.</p>
<p>A fair allocation instance is denoted by $I=(N,M,v)$ where $v=(v_1,\cdots,v_n)$ is the vector of valuation functions and can be represented by a table with a row per agent and a column per good, s.t. cell $(i,g)$ contains the value $v_i(g)$.</p>
<p>An allocation is a tuple of subsets of $M$, $A=(A_1,\cdots,A_n)$ s.t. each agent $i\in N$ receives the bundle $A_i\subseteq M,A_i\cap A_j=\emptyset$ for every pair of agents $i,j\in N$ and $\cup_{i\in N}A_i=M$. If $\cup_{i\in N}A_i\subsetneq M$, the allocation is called partial.</p>
<h3 id="solution-concepts">Solution Concepts</h3>
<p>Objective: To compute a fair allocation i.e., an allocation that satisfies a desired fairness criterion.</p>
<p>Two fairness notions: envy-freeness and proportionality.</p>
<p>Envy-freeness:</p>
<blockquote>
<p>An allocation $A$ is envy-free (EF) if $v_i(A_i)\ge v_i(A_j)$ for every pair of agents $i,j\in N$.</p>
<p>所有人认为自己分到的东西比别人分到的东西价值都高的情况，称为<em>无嫉妒</em>的。</p>
</blockquote>
<p>Proportionality:</p>
<blockquote>
<p>An allocation $A$ is proportional (PROP) if $v_i(A_i)\ge\frac{v_i(M)}{n}$ for every agent $i\in N$.</p>
<p>所有人分到的东西都至少能达到他认为物品总价值的 $1\over n$ 的分配，成为<em>成比例</em>的。</p>
</blockquote>
<p>Obviously, $EF\rightarrow PROP,PROP\not\rightarrow EF$.</p>
<p>ER and PROP allocations do not always exist.</p>
<p>Even deciding whether an instance admits an EF or PROP allocation is NP-complete.</p>
<h3 id="important-relaxations">Important Relaxations</h3>
<h4 id="ef1">EF1</h4>
<p><strong>Envy-freeness up to one good</strong>. (Lipton et al. 2004; Budish. 2011)</p>
<blockquote>
<p>对于 $i$ 来说，如果另一个 $j$ 得到的物品集中去掉一个<strong>特定</strong>的物品，$i$ 就不再嫉妒 $j$ 了。</p>
</blockquote>
<ul>
<li>It is acceptable for an agent $i$ to envy another agent $j$, as long as there exists a good in $j$'s bundle the hypothetical removal of which would eliminate $i$'s envy towards $j$,</li>
<li>Definition: An allocation $A$ is EF1 if for every pair of agents $i,j\in N$, it holds that $v_i(A_i)\ge v_i(A_j\diagdown{g})$ for <strong>some</strong> $g\in A_j$.</li>
<li>A week notion of EF1: there are times when a very highly-valued good is hypothetically removed from  another agent's bundle.</li>
</ul>
<h4 id="efx">EFX</h4>
<p>To refine this week notion of EF1, we create stricter relaxation, <strong>envy-freeness up to any good</strong> aka EFX (Gourvès et al. 2014; Caragiannis et al, 2016)</p>
<blockquote>
<p>An allocation is said to be EFX if the envy of the agent $i$ towards agent $j$ can be eliminated by the hypothetical removal of <em>any</em> good in $j$'s bundle.</p>
<p>对于 $i$ 来说，如果另一个 $j$ 得到的物品集中去掉<strong>任意</strong>一个的物品，$i$ 就不再嫉妒 $j$ 了。</p>
</blockquote>
<ul>
<li>Definition: An allocation $A$ is EFX if for every pair of agents $i,j\in N$, it holds that $v_i(A_i)\ge v_i(A_j\diagdown{g})$ for <strong>any</strong> $g\in A_j$.</li>
</ul>
<p>The existence of EFX allocation is challenging open problem.</p>
<h4 id="mms">MMS</h4>
<p>maximin share fairness (Budish. 2011)</p>
<ul>
<li>
<p>Generalization of the rationale of the well-known cut-and-choose protocol.</p>
</li>
<li>
<p>Goal: Give each agent $i$ goods of value at least as much as her <em>maximin share</em> $\mu_i^n(M)$, which is the maximum value this agent could guarantee for herself by partitioning the set of goods $M$ into $n$ disjoint bundles and keeping the worst of them.</p>
</li>
<li>
<p>It is a relaxation of proportionality.</p>
</li>
<li>
<p>Definition: Let $\mathcal A_n(M)$ be the collection of possible allocations of the goods in $M$ to $n$ agents. An allocation $A$ is said to be MMS if for each agent $i\in N$,
  $$
  v_i(A_i)\ge\mu_i^n(M)=\max_{B\in\mathcal A_n(M)}\min_{S\in B}v_i(S)
  $$</p>
</li>
</ul>
<p>Computing MMS allocation or even computing the maximin share of an agent is an NP-hard problem.</p>
<p>MMS allocations do not always exists when there are more than 2 agents. (Kurokawa et al. 2018, 2016)</p>
<p>It's possible to compute <em>approximate MMS allocations</em>.</p>
<h2 id="envy-freeness-up-to-one-good-ef1">Envy-Freeness up to One Good (EF1)</h2>
<p>### Computing EF1 Allocations</p>
<h4 id="round-robin-algorithm">Round-Robin Algorithm</h4>
<p>Simplest polynomial time for EF1 allocation computing algorithm is <strong>Round-Robin</strong>.</p>
<ul>
<li>Allocates the goods to the agents in multiple rounds.</li>
<li>In each round, according to some arbitrarily fixed given ordering, each agent chooses her most valuable good among the available ones.</li>
</ul>
<p><strong>Theorem 1</strong>: Round-Robin computes an EF1 allocation.</p>
<h4 id="envy-cycle-elimination-algorithm">Envy-Cycle Elimination Algorithm</h4>
<p>Lipton et al. 2004</p>
<ul>
<li>
<p>Do not use a prefixed sequence for agents to select goods. Instead, it repeatedly chooses an agent that is in a disadvantage compared to other agents and gives an unallocated good.</p>
</li>
<li>
<p>The algorithm maintains a <em>envy graph</em>, where the nodes correspond to agents and there is an edge from agent $i$ to agent $j$ if $i$ is envious of $j$'s bundle.</p>
</li>
<li>
<p>At each step of algorithm, an unassigned good is allocated to some agent who is not envied by any other agent i.e., an agent corresponds to a node with in-degree 0 in the envy graph. If no such agent exists, the envy graph must contain a directed cycle, which can be eliminated by redistributing the current bundles among the agents that participate in the cycle.</p>
</li>
<li>
<p>The cycle can be resolved by exchanging the bundles of items along the cycle.</p>
</li>
<li>
<p>Repeating the procedure, eventually leads to a modified ency graph with at least one agent who is not envied by any other agent.</p>
</li>
</ul>
<p>==Personal comments: It is kind of like Top Trading Cycle Algorithm???==</p>
<p>Envy-Cycle Elimination Algorithm runs in polynomial time and outputs an EF1 allocation.</p>
<h3 id="ef1-and-pareto-optimal-po-allocations">EF1 and Pareto Optimal (PO) Allocations</h3>
<p>Besides fair, another desideratum is efficiency.</p>
<p>(Caragiannis et al. 2019) found inherent connection between EF1, Pareto optimality and <em>maximum Nash welfare (MNW)</em>.</p>
<p>Pareto optimal Allocations: An allocation $A$ is Pareto optimal if there is no allocation $B$ s.t. $v_i(B_i)\ge v_i(A_i)\forall i\in N$ and $v_j(B_j)\ge v_j(A_j)$ for some $j\in N$. Equivalently, we say such an allocation $B$ is not <em>Pareto dominated</em> by any other allocation.</p>
<p>MNW allocation: An allocation $A$ is MNW allocation if:</p>
<ol>
<li>It maximizes the number of agents with positive value</li>
<li>It maximizes the Nash welfare ($\prod_iv_i(A_i)$) for the agents with positive value.</li>
</ol>
<p><strong>Theorem 2</strong>: Every MNW allocation is EF1 and PO.</p>
<p>There exist allocations that combine fairness with Pareto efficiency. (Yuan and Suksompong 2023) showed that Nash Welfare is the only welfarist function of agent valuations whose maximization leads to allocations that are EF1 and PO.</p>
<p>Computing MNW allocation is hard. In pseudo-polynomial time. <strong>Still remains unknown whether this can be done in polynomial time</strong>.</p>
<p>:question:<strong>Open Problem 1: Can an EF1 and PO allocation be computed in polynomial time?</strong></p>
<h2 id="envy-freeness-up-to-any-good-efx">Envy-Freeness up to Any Good (EFX)</h2>
<p>The existence of EFX is challenging open problem.</p>
<h3 id="existence-and-computation-of-efx-allocations-for-special-cases">Existence and Computation of EFX Allocations for Special Cases</h3>
<h4 id="identical-valuations">Identical Valuations</h4>
<p>Plaut and Roughgarden 2020</p>
<p>Allocations that satisfy particular properties about the minimum value are EFX.</p>
<p>A <em>leximin</em> allocation is an allocation that first maximizes the minimum value among all bundles, then maximizes the second minimum value and so on.</p>
<p>leximin is not EFX, but add some slight refinement of it is in fact EFX:</p>
<ul>
<li>After maximizing the minimum value, the allocation must maximize the size of the bundle with minimum value before maximizing the second minimum value and so on.</li>
<li>Called <em>leximin++</em></li>
</ul>
<p>Any leximin++ allocation $A$ must be EFX.</p>
<h4 id="ordered-valuations">Ordered Valuations</h4>
<p>Plaut and Roughgarden 2020</p>
<p>Envy-Cycle elimination algorithm returns an EFX allocation for the slightly more general class of ordered instances, where the agents have identical orderings, but possibly distinct cardinal valuations.</p>
<ul>
<li>The ordering of the goods $g_1,\cdots,g_m$ s.t. $v_i(g_1)\ge \cdots\ge v_i(g_m)\forall i\in N$.</li>
</ul>
<p><strong>Theorem 3</strong>: The Envy-Cycle Elimination Algorithm computes an EFX allocation for every ordered instance.</p>
<h4 id="efx-for-2-and-3-agents">EFX for 2 and 3 Agents</h4>
<p>We can compute EFX allocation using a <em>divide-and-choose</em> approach that exploits the existence of EFX allocations for agents with identical valuations.</p>
<p><strong>Theorem 4</strong>: EFX allocations always exist for instances with 2 agents.</p>
<p>(Goldberg et al. 2023) showed that it's possible to efficiently compute EFX allocations when there are only two agents for some more general valuation functions such as gross substitute or budget-additive, but problem becomes PLS-complete for sub-modular functions.</p>
<p>Computing EFX allocations for 3 agents in polynomial time is still an open problem.</p>
<p><a href="https://en.wikipedia.org/wiki/Submodular_set_function">Sub-modular function</a> $f$:
$$
f(A\cup{i})-f(A)\ge f(B\cup{i})-f(B)\forall A\subseteq B\subseteq N\text{ and }i\in N\diagdown B
$$</p>
<blockquote>
<p>“边际效用递减”</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/PLS_(complexity)">PLS-complete</a>: Polynomial Local Search complete. A problem is PLS-complete if it is PLS and any problem in PLS can be reduced to it in polynomial time.</p>
<h4 id="bi-valued-valuation">Bi-valued Valuation</h4>
<p>Only 2 distinct possible values that an agent may have for the goods.</p>
<p>(Amandatidis et al. 2021) showed that EFX allocations exist and can be efficiently computed for any number of agents.</p>
<p>(Garg and Murhekar 2021) showed that this is possible even in conjunction with PO.</p>
<p>(Amandatidis et al. 2021) also demonstrated an interesting connection between EFX and MNW allocation for bi-valued instances. MNW allocations always satisfy EFX.</p>
<h4 id="discussion_1">Discussion</h4>
<p>Original definition of EFX is a bit weaker because it requires the removed good to be positively-valued.</p>
<p>:question:<strong>Open Problem 2: Do EFX allocations exist for instance with $n\ge4$ agents and unrestricted additive valuations?</strong></p>
<h3 id="relaxations-of-efx">Relaxations of EFX</h3>
<p>Family of <em>Approximately EFX</em></p>
<p>$\alpha$-EFX: Let $\alpha\in[0,1]$, An allocation is $\alpha$-EFX if for every pair of agents $i,j\in N$, $v_i(A_i)\ge\alpha \cdot v_i(A_j\diagdown{g})$ for any $g\in A_j$.</p>
<p>(Plaut and Roughgarden 2020) showed $\frac{1}{2}$-EFX allocations always exist even for sub-additive valuation functions.</p>
<p>Sub-additive function: $v(A\cup B)\le v(A)+v(B)$</p>
<p>(Chan et al 2019) showed that computing such allocations can be done in polynomial time.</p>
<p><strong>Theorem 5</strong>: The Envy-Cycle Elimination algorithm computes a $1\over2$-EFX allocation.</p>
<p>The approximation ratio for the additive case was improved by (Amandatidis et al. 2020) to 0.618 by combining Round-Robin and Envy-Cycle Elimination with some appropriate pre-processing.</p>
<p>:question:<strong>Open Problem 3: What is the best possible $\alpha$ for which $\alpha$-EFX allocations exist?</strong></p>
<p>==如果对于开放问题 3，$\alpha=1$ 成立，那么开放问题 2 也成立。如果开放问题 2 的答案是否定的，那么开放问题 3 就有重大意义。==</p>
<p>Additionally, as is the case for all of these notions, the next natural question is whether existence can be paired with polynomial-time algorithms for finding such allocations.</p>
<p>Another recent approach is that of relaxing the requirement to allocate all available goods. Clearly, if done without any constraints, this makes the problem trivial: simply leaving all good unallocated. Here objective is to only leave few goods unallocated or remove some goods without affecting the maximum possible Nash social welfare by too much.</p>
<p>(Caragiannis et al. 2019) showed that it is possible to compute an EFX allocation of a subset of the good the Nash welfare of which is at least half of the maximum Nash welfare on the original set.</p>
<p>(Chaudhury et al. 2021) presented an algorithm that computes a partial EFX allocation, but the number of unallocated goods is at most $n-1$.</p>
<p>(Berger et al. 2022) showed the unallocated goods can be decreased to $n-2$.</p>
<p>(Chaudhury et al. 2021) showed that a $(1-\epsilon)$-EFX allocation with a sub-linear number of unallocated goods and high Nash welfare can be computed in polynomial time for every constant $\epsilon\in(0,0.5]$.</p>
<p>:question:<strong>Open Problem 4: Is it possible to achieve an exact EFX allocation by donating a sub-linear number of goods?</strong></p>
<h2 id="maximin-share-fairness-mms">Maximin Share Fairness (MMS)</h2>
<p>MMS significantly weakens the requirement of PROP. But MMS are not guaranteed to exist.</p>
<p>The trend is focusing on <em>approximate MMS allocations</em>.</p>
<p>$\alpha$-MMS: Let $\alpha\in[0,1]$. An allocation $A$ is $\alpha$-MMS if $v_i(A_i)\ge\alpha\cdot \mu_i^n(M)\forall i\in N$.</p>
<p>Monotonicity of the MMS values: remove one agent and one good from the instance, the MMS value of each of the remaining agents in the remaining instance does not increase.</p>
<p><strong>Lemma 1</strong>: For any agent $i$ and any good $g$, $\mu_i^{n-1}(M\diagdown{g})\ge\mu_i^n(M)$.</p>
<p>Lemma 1 suggests that if there is a large good $g$ that satisfies the desired approximation of MMS value for some agent $i$, we can simply assign $g$ to $i$ and finalize the bundle $A_i={g}$ without hurting the remaining agents in the reduced instance.</p>
<h3 id="computing-1over2-mms-allocations">Computing $1\over2$-MMS Allocations</h3>
<p>Consider simple algorithms for computing $1\over2$-MMS Allocations in polynomial time. (Better approximation can be achieved by variants and extensions of the techniques employed by these algorithms)</p>
<p>The monotonicity of the MMS value allows us to focus only on the case when the agents have sufficiently small value for the goods, in particular, $v_i(g)\le\frac{\mu_i^n}{2}$ for every $i\in N,g\in M$. As long as there is an agent $i$ and a good $g$ s.t. $v_i(g)\gt\frac{\mu_i^n}{2}$, we can allocate $g$ to $i$ so that $i$ obtains half of her MMS value, and never consider $i$ to $g$ again. If we guarantee $1\over2$-MMS for the remaining agents in the reduced instance, the same guarantee must also hold in the original instance by Lemma 1.</p>
<p>One way to achieve this is by using Round-Robin.</p>
<p><strong>Lemma 2</strong>: If $v_i(g)\lt\frac{\mu_i^n}{2}$ for eveery $i\in N,g\in M$, the Round-Robin algorithm returns an allocation that is $1\over2$-MMS.</p>
<p><strong>Theorem 6</strong>: The Envy-Circle Elimination algorithm computes a $1\over2$-MMS allocation.</p>
<p><strong>Theorem 7</strong>: The Bag-Filling Algorithm returns a $1\over2$-MMS allocation.</p>
<blockquote>
<p>Bag here means donation bag.</p>
<p>就是保留某些物品不分配给任何一个玩家（相当于直接捐给慈善机构）</p>
</blockquote>
<h3 id="better-approximations">Better Approximations</h3>
<p>(Kurokawa et al. 2018) showed how to find $2\over3$-MMS allocation (but not in polynomial time)</p>
<p>(Amanatidis et al. 2017) matched this guarantee in polynomial time.</p>
<p>Simpler algorithms rely on important property that the hardest case is when the agents have the same order of preference over the goods:</p>
<p>Given any instance $I=(N,M,v)$ which may not be ordered, we can construct corresponding ordered instance $I'=(N,M,v')$. Based on an ordering $\succ$ of the goods, for each agent $i\in N$, we find a permutation $\sigma_i:M\rightarrow N$ s.t. $v_i(\sigma_i(g))\ge v_i(\sigma_i(g'))$ for every $g\succ g'$. Then we define a new valuation function $v_i'$ with $v_i'(g)=v_i(\sigma_i(g))$ for every $g\in M$; hence, the new value of $i$ for good $g$ that ranked $l$-th in $\succ$ equals the $l$-th highest value of $i$ in original valuation. Hence, if $I'$ admits MMS then $I$ admits an MMS as well (same holds for approximate MMS allocations).</p>
<p><strong>Lemma 3</strong>: Let $I=(N,M,v)$ be any instance, $I'$ be its corresponding instance, and $A'=(A_1',\cdots,A_n')$ be an allocation for $I'$ s.t. $v_i'(A_i')\ge\alpha_i$ for every $i\in N$. Then, we can construct in polynomial time an allocation $A=(A_1,\cdots,A_n)$ for $I$ s.t. $v_i(A_i)\ge\alpha_i$ for every $i\in N$.</p>
<p>(Barman and Krishnamurthy 2020) showed the Envy-Cycle Elimination algorithm returns a $2\over3$-MMS allocation for ordered instances, thus $2\over3$-MMS fair allocation can be found in polynomial time for every instance due to Lemma 3.</p>
<p>(Ghodsi et al. 2021) designed an $(\frac{3}{4}-\epsilon)$-approximation algorithm.</p>
<p>(Garg and Taki 2021) improved approximation guarantee of $\frac{3}{4}+\frac{1}{12n}$.</p>
<p>(Feige et al. 2021) showed that it's impossible to achieve an approximation bound better than $39\over40$.</p>
<p>:question:<strong>Open Problem 5: Is it possible to improve upon the bound of $\frac{3}{4}+\frac{1}{12n}$ for additive valuations? Is there a stronger inapproximability bound than $39\over40$?</strong></p>
<h3 id="restricted-instances">Restricted Instances</h3>
<p>By restricting the number of agents or the space of the valuation functions, one can get stronger results.</p>
<p>MMS for four or fewer agents.</p>
<ul>
<li>Two agents: a simple cut-and-choose-type protocol always produce an MMS allocation.</li>
</ul>
<p>The first agent partitions the set of goods as equally as possible and the second agent decides who gets each of these sets.</p>
<ul>
<li>
<p>The first step is computationally hard but producing a $(1-\epsilon)$-MMS allocation in polynomial time.</p>
</li>
<li>
<p>(Kurokawa et al. 2018) guarantees a approximation of $2\over3$, for three or four agents it guarantees $3\over4$ approximation.</p>
</li>
<li>
<p>(Amanatidis et al. 2017) improved approximation factor for three agents to $7\over8$. (Gourvès and Monnot 2019) improved to $8\over9$. (Feige and Norkin 2022) improved to $11\over12$.</p>
</li>
<li>
<p>(Ghodsi et al. 2021) improved approximation factor for four agents to $4\over5$.</p>
</li>
</ul>
<p>MMS for restricted valuations.</p>
<ul>
<li>All agents have the same valuation functions.</li>
<li>(Bouveret and Lemaître 2016) showed that unlike EFX, the hardest instances for MMS are the ordered instances.</li>
<li>MMS allocations always exist and can be computed efficiently for ternary valuation function（三元估值函数） (Amanatidis et al. 2017) and for bi-valued valuation functions (Feige 2022)</li>
<li>(Ebadian et al. 2022) showed that this is also the case when there are at most two values per agent and for general instances where the value of each good is at least as much as the value of all less valuable goods combined.</li>
<li>MMS allocations are known to exist is that of <a href="https://en.wikipedia.org/wiki/Matroid_rank">matroid-rank</a> valuations</li>
</ul>
<p>:question:<strong>Open Problem 6: Are there other classes of structured valuations for which MMS is guaranteed to exist, e.g., when there are only a few possible values?</strong></p>
<h2 id="further-notable-fairness-notions">Further Notable Fairness Notions</h2>
<p>Other notable fairness beyond EF, PROP, EF1, EFX, MMS.</p>
<h3 id="efl-efr-and-epistemic-notions">EFL, EFR, and Epistemic Notions</h3>
<p>EFL aka envy-freeness up to one less-preferred good (Barman et al. 2018)</p>
<ul>
<li>
<p>EFL is between EF1 and EFX.</p>
</li>
<li>
<p>An agent $i$ does not envy another agent $j$ if either $A_j$ contains at most one good that $i$ values positively, or thee envy of $i$ can be eliminated by the hypothetical removal of a good $g\in A_j$ s.t. $v_i(A_i)\ge v_i(g)$</p>
</li>
<li>EFL always exists, and can be computed using a variant of the Envy-Circle Elimination algorithm.</li>
</ul>
<p>EFR aka envy-freeness up to a random good (Farhadi et al. 2021)</p>
<ul>
<li>The envy of agent $i$ towards another agent $j$ can be eliminated in expectation after the hypothetical removal of a randomly chosen good from $A_j$.</li>
<li>$0.73$-EFR allocation can be computed in polynomial time.</li>
</ul>
<p>:question:<strong>Open Question 7: Do EFR allocations always exist?</strong></p>
<p>Epistemic Fairness</p>
<ul>
<li>
<p>Agents do not have complete knowledge about the computed allocation.</p>
</li>
<li>
<p>(Aziz et al. 2018) considered a setting where the agents are connected via a social network and do not know the bundles allocated to the agents who are not their neighbor. They introduced <strong>epistemic EF</strong> under which an agent is satisfied only if there are a redistribution of the goods she is not aware of s.t. the resulting allocation is EF to her.</p>
</li>
</ul>
<p>(Caragiannis et al 2022) proved the existence of epistemic EFX allocations for additive valuations when the underlying social network contains only isolated nodes.</p>
<h3 id="pmms-and-gmms">PMMS and GMMS</h3>
<p>Variations of MMS</p>
<p><strong>PMMS aka pairwise maximin share fairness</strong> (Caragiannis et al 2019)</p>
<ul>
<li>Every pair of agents $i$ and $j$, $i$'s value for $A_i$ must be at least as much as the maximum she could obtain by redistribution the set of goods in $A_i\cup A_j$ into two bundles and picking the worst of them.</li>
<li>PMMS requires that it is achieved for any pair of agents.</li>
</ul>
<p>$\alpha$-PMMS: Let $\alpha\in[0,1]$. An allocation $A$ is $\alpha$-PMMS if $v_i(A_i)\ge\alpha\cdot\mu_i^2(A_i\cup A_j)\forall i,j\in N$. When $\alpha=1$, the allocation is called PMMS.</p>
<p>:question:<strong>Open Problem 8: Do PMMS allocations always exist?</strong></p>
<p>Any PMMS allocation must be EFX, thus showing the existence of PMMS allocations would also imply the existence of EFX allocations. For approximate PMMS, the best known result is $0.781$ by (Kurokawa 2017).</p>
<p><strong>GMMS aka groupwise maximin share fairness</strong> (Barman et al. 2018)</p>
<ul>
<li>Stronger notion</li>
<li>The maximin share guarantee is simultaneously achieved for any possible subset of agents.</li>
</ul>
<p>$\alpha$-GMMS: Let $\alpha\in[0,1]$. An allocation $A$ is $\alpha$-GMMS if $v_i(A_i)\ge\alpha\cdot\text{GMMS}<em>i$ for all $i\in N$, where
$$
\text{GMMS}_i=\max</em>{S\subseteq N:i\in S}\mu_i^{|S|}(\bigcup_{j\in S}A_j)
$$
when $\alpha=1$, the allocation is called GMMS.</p>
<ul>
<li>(Barman et al. 2018) showed that GMMS allocations exist for some restricted settings, such as when the agents have binary or identical values. EFL allocation is $1\over2$-GMMS, such an allocation can be computed efficiently.</li>
<li>Best known approximation of GMMS is $4\over7$ (Amanatidis et al. 2020; Chaudhury et al. 2021)</li>
</ul>
<p>:question:<strong>Open Problem 9: What is the best possible $\alpha$ for which $\alpha$-GMMS allocations exist?</strong></p>
<h3 id="prop1-propx-and-propm">Prop1, PropX and PropM</h3>
<p>Relaxation of proportionality.</p>
<p><strong>Prop1 aka proportionality up to one good</strong> (Conitzer et al. 2017)</p>
<ul>
<li>Each agent could obtain her proportional share if given one extra good.</li>
<li>An allocation $A$ is Prop1 if for every agent $i\in N$, there <strong>exists a good</strong> $g\in M\diagdown A_i$ s.t. $v_i(A_i\cup{g})\ge\frac{v_i(M)}{n}$.</li>
</ul>
<p><strong>PropX aka proportionality up to any good</strong> (Aziz et al. 2020)</p>
<ul>
<li>Each agent could obtain her proportional share when given the least positively-valued good among those allocated to other agents.</li>
<li>An allocation $A$ is PropX if for every agent $i\in N$ and <strong>any good</strong> $g\in M\diagdown A_i$, we have $v_i(A_i\cup{g})\ge\frac{v_i(M)}{n}$.</li>
</ul>
<p>An allocation that is Prop1 and PO always exists (Conitzer et al. 2017) and can be computed in polynomial time. (Barman and Krishnamurthy 2019)</p>
<p>PropX is rather demanding and it can not always be guaranteed. (Aziz et al. 2020)</p>
<p><strong>PropM aka proportionality up to maximin good</strong> (Baklanov et al 2021)</p>
<ul>
<li>
<p>Middle-ground between Prop1 and PropX.</p>
</li>
<li>
<p>Given an allocation $A$, the value of a maximin good for agent $i$ is
  $$
  d_i(A)=\max_{j\neq i}\min_{g\in A_j}v_i(g),
  $$
  and $A$ is called PropM if $v_i(A_i)+d_i(A)\ge\frac{v_i(M)}{n}$.</p>
</li>
<li>
<p>PropM always exists and can be computed in polynomial time.</p>
</li>
</ul>
<h3 id="equitability-and-its-relaxations">Equitability and its Relaxations</h3>
<p>Besides envy-freeness and proportionality, another important fairness notion is that of <strong>equitability</strong> according to which all agents must derive the same value from the bundles they are allocated.</p>
<p>Definition of Equitability (EQ) (Brams and Taylor 1996): An allocation $A=(A_1,\cdots,A_n)$ is equitable if $v_i(A_i)=v_j(A_j)$ for every pair of agents $i,j\in N$.</p>
<ul>
<li>EQ allocation may not exist. similarly to EF1 and EFX, we can relax EQ1 and EQX.</li>
</ul>
<p><strong>EQ1</strong>: An allocation $A$ is equitable up to one good if, for every pair of agents $i,j\in N$, it holds that $v_i(A_i)\ge v_j(A_j\diagdown{g})$ for <strong>some</strong> $g\in A_j$.</p>
<p><strong>EQX</strong>: An allocation $A$ is equitable up to any good if, for every pair of agents $i,j\in N$, it holds that $v_i(A_i)\ge v_j(A_j\diagdown{g})$ for <strong>any</strong> $g\in A_j$.</p>
<p>Obviously EQX is EQ1.</p>
<p>(Gourvès et al. 2014) showed that EQX allocation under the <em>nearly jealousy-free</em> always exist and can be computed in polynomial time.</p>
<h2 id="beyond-fairness-efficiency-and-incentives">Beyond Fairness: Efficiency and Incentives</h2>
<p>Relation between fairness and efficiency. Possibility of achieving fairness when the agents are strategic.</p>
<h3 id="fair-and-pareto-optimal-allocations">Fair and Pareto Optimal Allocations</h3>
<p>Whether it is possible to simultaneously achieve fairness and efficiency.</p>
<p>Common type of efficiency: Pareto Optimality, can be guaranteed in conjunction with some fairness notions like EF1 and Prop1.</p>
<p>(Caragiannis et al. 2019) showed that any allocation that maximizes the Nash welfare is EF1 and PO. But computation of Nash welfare maximizing allocations is NP-hard.</p>
<p>For computation of allocations that are fair and PO, a commonly used technique is to exploit the connection between fair division and <em>market equilibria in Fisher markets</em> (Budish 2011), which has been widely used in the design of approximation algorithms for maximizing the Nash welfare (Cole and Gkatzelis 2018; Cole et al. 2017).</p>
<p><strong>A Fisher market</strong> consists of a set of agents $N$, a set of goods $M$, and each agent $i\in N$ has a value $v_i(g)$ for every good $g\in M$. In contrast to discrete fair division, each agent $i$ also has a <em>budget</em> $b_i\ge0$, and the goods can be fractionally allocated. A fractional allocation is a tuple of vectors $X=(x_i)<em>{i\in N}$, where $x_i=(x</em>{i1},\cdots,x_{im})$; in particular, $x_{ig}\in[0,1]$ denotes the fraction of $g$ that is allocated to $i$, s.t. $\sum_{i\in N}x_{ig}\le1$ for every $g\in M$.</p>
<p>Focusing on Fisher markets with <em>linear utilities</em>, $v_i(x_i)=\sum_{g\in M}x_{ig}\cdot v_i(g)$. A market outcome is a tuple $(X,p)$, where $X$ is a fractional allocation and $p=(p_1,\cdots,p_m)$ defines the price $p_j$ for item $j$.</p>
<p>An outcome $(X,p)$ is a market equilibrium if it satisfies the following conditions:</p>
<ol>
<li>The market clears (all items are completely allocated): $\sum_{i\in N}x_{ig}=1$ for every $g\in M$ with $p_g\ge0$.</li>
<li>The budgets of all agents are exhausted: $\sum_{g\in M}p_g\cdot x_{ig}=b_i$ for every $i\in N$.</li>
<li>The agents only spend money on the goods with maximum value per unit of money spent (bang-per-pack): For any $g\in M$, $x_{ig}\gt0$ implies $\frac{v_i(g)}{p_g}\ge\frac{v_i(g')}{p_{g'}}$ for every $g'\in M$.</li>
</ol>
<p><strong>Fractional Pareto Optimal (fPO)</strong>: An allocation is fPO if it's not Pareto dominated by any fractional allocation.</p>
<p>An fPO allocation is also PO.</p>
<p>When all agents have the same budget (i.e., a <em>competitive equilibrium from equal income, CEEI</em>), the allocation is EF (Varian 1974).</p>
<p>(Barman et al. 2018) compute allocations by perturbing the budgets or the values in the market so that they admit market equilibria with integral allocations.</p>
<p>(Barman et al. 2018) designed a pseudo-polynomial time algorithm to compute an allocation that is EF1 and PO.</p>
<blockquote>
<p>Pseudo-polynomial aka 伪多项式时间复杂度，比如 01 背包的动态规划算法就是伪多项式时间复杂度的。</p>
</blockquote>
<p>(Barman and Krishnamurthy 2019) designed a strongly polynomial time algorithm to compute an allocation that is PROP1 and PO.</p>
<p>(Garg and Murhekar 2021) showed that in bi-valued instances, an EFX and PO allocation can be computed in polynomial time, but in instances with 3 distinct values, EFX and PO are incompatible.</p>
<p>(Freeman et al. 2019) showed that if all values are strictly positive, there always exists a EQX and PO allocation. But there do not exist EQ1 and PO allocations when the values can be 0.</p>
<p>(Garg and Murhekar 2022) provided a pseudo-polynomial time algorithm to compute an EQ1 and PO allocation.</p>
<h4 id="approximating-the-nash-welfare">Approximating the Nash Welfare</h4>
<p>MNW are both EF1 and PO.</p>
<p>Worthy probelm: Efficiently computing approximate maximum Nash welfare allocations</p>
<p>(Garg et al. 2017) showed that approximating the Nash welfare within a ratio better than $1.069$ is NP-hard, even for additive valuation functions with only four values; in fact it is APX-hard to approximate the Nash welfare even when there only two values (Akrami et al. 2022).</p>
<p><a href="https://en.wikipedia.org/wiki/APX">APX</a></p>
<blockquote>
<p>aka Polynomial-time approximation algorithms with approximation ratio bounded by a constant.</p>
</blockquote>
<p>For additive valuations, the best known approximation is $e^{\frac{1}{e}}+\epsilon\approx1.45$. (Barman et al. 2018)</p>
<p>For all agents have submodular valuation functions, the best known approximation of Nash welfare is $6+\epsilon$ (Garg et al. 2022) and the best known lower bound is $1.5819$ (Garg et al. 2020).</p>
<p>Under the value oracle model, asymptotically tight approximation ratio of $\Theta(n)$ for both XOS and subadditive functions. (Barman et al. 2020; Chaudhury et al. 2021)\</p>
<p><a href="https://en.wikipedia.org/wiki/Demand_oracle">Value oracle</a></p>
<p>XOS (aka XOR of Sum)</p>
<blockquote>
<p>A set function $f:2^N\rightarrow\mathbb R$ is considered XOS if it can be represented as the XOR (exclusive OR) of linear threshold functions. Mathematically, a XOS function can be written as
$$
f(S)=\bigoplus_{i=1}^kg_i(S)
$$</p>
<ul>
<li>
<p>$S$ is a subset of elements from the ground set $N$.</p>
</li>
<li>
<p>$\bigoplus$ denotes the XOR operation.</p>
</li>
<li>
<p>$g_i(S)$ represents a linear threshold function on subset $N$.
  $$
  g_i(S)=\begin{cases}
  1,|S|\ge\theta_i\
  0,\text{otherwise}
  \end{cases}
  $$</p>
</li>
</ul>
</blockquote>
<p>With stronger oracle assumptions, a sublinear approximation ratio is possible for XOS functions (Barman et al. 2021)</p>
<p>Whether sublinear approximation ratios are possible for subadditive functions with stronger oracle assumption remains unknown.</p>
<h4 id="egalitarian-welfare">Egalitarian Welfare</h4>
<p>Egalitarian welfare is the minimum utility among all agents.</p>
<p>To maximize the egalitarian welfare is a known APX-hard problems.</p>
<p>While egalitarian welfare maximizing allocations are clearly PO, they may not achieve any constant approximation of important relaxations of EF and PROP, such as EF1 and MMS.</p>
<h3 id="price-of-fairness-pof">Price of Fairness (PoF)</h3>
<p>Another natural goal is to approximately maximize some <strong>objective function of the values</strong> of the agents such as social welfare, i.e. total value of the agents for the goods they receive（上课讲过）.</p>
<p>Social welfare of an allocation $A$:
$$
SW(A)=\sum_{i\in N}v_i(A_i)
$$
(Bertsimas et al. 2011) and (Caragiannis et al. 2012) defined the <em>Price of Fairness</em></p>
<ul>
<li>Similar to approximation ratio in worst-case analysis which measures the deterioration of the objective due to the fairness requirement.</li>
<li>Given an instance $I$, we denote by $OPT(I)$ the maximum social welfare over all allocations of $I$. Let $F$ be a fairness criterion (such as EF1 and MMS) and $F(I)$ be the set of all allocations satisfying $F$.</li>
</ul>
<p>Definition of PoF: 
$$
PoF=\sup_{I}\min_{A\in F(I)}\frac{OPT(I)}{SW(A)}\
=\frac{\max_{D\in Divisions}SW(D)}{\max_{D\in Fair\ Divisions}SW(S)}
$$
If no fair allocation can achieve non-zero welfare, the PoF is infinite.</p>
<p>The price of fairness w.r.t. fairness criterion $F$ is also called the price of $F$.</p>
<p>(Bei et al. 2021) first consider the PoF w.r.t. relaxations of EF. For instances with 2 agents, the price of EF1 is at least $8\over7$.</p>
<p>An upper bound on the price of EF1 follows by a variant of the Adjusted-Winner algorithm (Brams and Taylor 1996). The idea is to sort the goods according to the ratios between the values that they yield to the 2 agents:
$$
\frac{v_1(g_1)}{v_2(g_1)}\ge\frac{v_1(g_2)}{v_2(g_2)}\ge\cdots\ge\frac{v_1(g_m)}{v_2(g_m)}
$$
Intuitively, the first good is more valuable to agent 1 while the last good is more valuable to agent 2. If a minimal set of consecutive goods from left is allocated to the first agent s.t. the allocation is EF1 for her and the remaining goods are given to agent 2, then the allocation is EF1 with social welfare that is within a $\frac{\sqrt 3}{2}$-fraction of the optimal social welfare.</p>
<p>For arbitrary number of agents</p>
<ul>
<li>(Bei et al. 2021) showed that a lower bound of $\Omega(\sqrt n)$ on the price of EF1.</li>
<li>(Barman et al. 2020) managed to give a tight upper bound of $O(\sqrt n)$, also showed tight bounds for other fairness notions, for $1\over2$-MMS and Prop1.</li>
<li>(Halpern and Shah 2021) showed tight bounds on the price of EF1 and of approximate MMS under the constraint of having only ordinal information about the agent values.</li>
<li>A typical assumption made in the context of distortion in social choice (Anshelevich et al. 2021).</li>
</ul>
<h3 id="fair-division-with-strategic-agents">Fair Division with Strategic Agents</h3>
<p>In the strategic version of the problem, an agent may intentionally misreport the values of goods in order to end up with a better bundle.</p>
<p>This introduces an additional layer of difficulty as goal is to produce fair allocations <em>according to the true values of the agents</em> while declarations might be not true.</p>
<p>This version of problem is considered mostly from a mechanism design <em>without payment</em> perspective, in which the utility of an agent is defined as her true value for her bundle.</p>
<h4 id="direction-1-both-truthful-and-fair-mechanism">Direction 1: Both truthful and fair mechanism.</h4>
<ul>
<li>(Caragiannis et al. 2009) showed that no truthful mechanism for 2 agents and 2 goods can always output allocations of minimum envy.</li>
<li>(Amanatidis et al. 2016) revisited the problem for the case of 2 agents and any number of goods, and showed that no truthful mechanism can always output $\alpha$-MMS allocations for $\alpha\gt\frac{2}{m}$.</li>
<li><strong>Truthfulness and fairness are incompatible</strong> (Amanatidis et al. 2017) This conclusion does not apply to restricted cases.</li>
<li>For binary valuations, maximizing the Nash welfare results in a polynomial-time truthful mechanism that outputs EF1 and PO allocations. Analogous result w.r.t. MMS.</li>
<li>(Babaioff et al) also showed that for the submodular analog of binary valuations, there is a truthful mechanism that always outputs EFX allocations.</li>
</ul>
<p>The impossibility results led to different directions.</p>
<h4 id="direction-2-stable-states-of-non-truthful-mechanisms">Direction 2: Stable states of non-truthful mechanisms.</h4>
<ul>
<li>(Amanatidis et al. 2021) studied mechanisms that always have pure Nash equilibria, and showed that every allocation that corresponds to an equilibrium of Round-Robin is EF1 w.r.t. the true value of the agents.</li>
<li>Similar results for approximate pure Nash equilibria, even for agents with submodular valuation functions (Amanatidis et al. 2023)</li>
<li>Strategic setting for general sequential allocation algorithms. (Bouveret and Lang 2014; Aziz et al. 2017)</li>
</ul>
<p>:question:<strong>Open Problem 10: Are there mechanisms that always have pure Nash equilibrium allocations with stronger guarantees than EF1?</strong></p>
<h4 id="direction-3-relaxing-the-requirements-of-truthfulness">Direction 3: Relaxing the requirements of truthfulness</h4>
<p>In order to escape from the impossibility.</p>
<p><em>Not obviously manipulability</em> (Psomas and Verma 2022)</p>
<ul>
<li>A mechanism is not obviously manipulable (NOM) if no agent can increase her best- and worst-case value by lying.</li>
</ul>
<p>Fortunately, Round-Robin is NOM thus EF1 and NOM are compatible.</p>
<p>EF1, PO and NOM can be achieved simultaneously.</p>
<h2 id="different-setting">Different Setting</h2>
<p>Further meaningful discrete fair division settings.</p>
<h3 id="limited-information">Limited Information</h3>
<p>Only ordinal information is available.</p>
<p>Given only the ordinal preferences of the agents: Envy-Cycle Elimination not works. Sequential-picking algorithm instead.</p>
<p>Round-Robin algorithm can obtain EF1 only needs to know which of the available goods every agent values the most in each round.</p>
<p>Harder to compute approximate MMS allocations.</p>
<p>Let $H_n=\sum_{i=1}^n\frac{1}{i}$, (Halpern and Shah 2021) showed that with only ordinal information, it is impossible to achieve better than $\frac{1}{H_n}$-MMS</p>
<p>(Amanatidis et al. 2016) showed that $\frac{1}{2H_n}$-MMS allocations can be computed.</p>
<p>(Hosseini et al. 2021) showed the existence of PO and MMS or EFX allocations when agents have lexicographic preferences.</p>
<p>Another question: Query complexity of unknown valuations.</p>
<ul>
<li>The algorithm can access the valuations by making queries to an oracle.</li>
<li>(Oh et al. 2021) proved that $\Theta(\log m)$ queries suffice to define an algorithm that returns EF1 allocations.</li>
<li>It's an important research direction to explore the relation between the amount of information and fairness guarantees.</li>
</ul>
<h3 id="general-valuations">General Valuations</h3>
<h4 id="variant-of-additive-valuations">Variant of additive valuations</h4>
<p>submodular, fractional subadditive, subadditive</p>
<p>Submodular: $v_i(S)+v_i(T)\ge v_i(S\cup T)+v_i(S\cap T)$</p>
<p>Subadditive: $v_i(S)+v_i(T)\ge v_i(S\cup T)$</p>
<p>XOS: finite number of additive functions $a_1,\cdots,a_k$ s.t. $v_i(S)=\max_{l\in[k]}a_l(S)$</p>
<p>Any additive function is submodular, any submodular function is XOS, any XOS function is subadditive.</p>
<p>The Envy-Cycle Elimination algorithm returns an EF1 allocation even when the valuation functions of the agents are as general as possible.</p>
<h4 id="mms_1">MMS</h4>
<p>For MMS allocations, if the functions are not restricted, no approximation guarantee can be achieved.</p>
<p>Some literature focus on structured valuations:</p>
<ul>
<li>(Barman and Krishnamurthy 2020) proved that the Round-Robin algorithm returns a $0.21$-approximate MMS fair allocation for submodular valuations.</li>
</ul>
<p>The guarantee was improved to $1\over3$ by (Ghodsi et al. 2022), who complemented with an upper bound of $3\over4$.</p>
<ul>
<li>For XOS valuations, (Ghodsi et al. 2022) proved the existence of $1\over5$-MMS allocations, and designed a polynomial-time algorithm to compute $1\over8$-MMS allocations.</li>
</ul>
<p>The existence result was improved to $1\over4.6$ by (Seddighin and Seddighin 2022)</p>
<p>(Ghodsi et al 2022) showed that no algorithm can do better than $1\over2$-approximation for all XOS valuations.</p>
<ul>
<li>For subadditive valuations, (Seddighin and Seddighin 2022) proved the existence of a $\Omega(\frac{1}{\log n\log\log n})$-MMS allocation, later improved the $\Omega(\frac{1}{\log m})$ guarantee by (Ghodsi et al. 2022).</li>
</ul>
<p>Best known approximations of MMS for general valuations:</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">lower bound</th>
<th style="text-align: center;">upper bound</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Additive</td>
<td style="text-align: center;">$\frac{3}{4}+\frac{1}{12n}$</td>
<td style="text-align: center;">$39\over40$</td>
</tr>
<tr>
<td style="text-align: center;">Submodular</td>
<td style="text-align: center;">$1\over3$</td>
<td style="text-align: center;">$3\over4$</td>
</tr>
<tr>
<td style="text-align: center;">XOS</td>
<td style="text-align: center;">$1\over4.6$</td>
<td style="text-align: center;">$1\over2$</td>
</tr>
<tr>
<td style="text-align: center;">Subadditive</td>
<td style="text-align: center;">$\Omega(\frac{1}{\log n\log\log n})$</td>
<td style="text-align: center;">$1\over2$</td>
</tr>
</tbody>
</table>
<h4 id="efx_1">EFX</h4>
<ul>
<li>(Plaut and Roughgarden 2020) proved that $1\over2$-EFX allocations always exist for general valuations.</li>
</ul>
<p>(Chan et al. 2019) showed that computing such allocations can be done in polynomial time.</p>
<ul>
<li>(Akrami et al. 2022) proved that, for instances with three agents, if one of them has an additive valuation and the others have general valuations, an exact EFX allocation always exists.</li>
</ul>
<h3 id="arbitrary-entitlements">Arbitrary Entitlements</h3>
<p>Fairness of an allocation must be considered w.r.t. asymmetric entitlements. In many inheritance scenarios, closer relatives have higher entitlements than distant ones.</p>
<p>Formally, in <em>weighted</em> and <em>asymmetric</em> setting, each agent $i$ has an entitlement $0\lt s_i\lt1$ s.t. $\sum_{i\in N}s_i=1$</p>
<p>The traditional setting with symmetric agents is a special case when $s_i=\frac{1}{n}$ for every $i$.</p>
<p>Generalized fair notions like weighted EF1, weighted MMS</p>
<ul>
<li>An allocation is weight envy-free (WEF) if $\frac{v_i(A_i)}{s_i}\ge\frac{v_i(A_j)}{s_j}$ for every pair of agents $i,j\in N$.</li>
<li>An allocation is weighted envy-free up to one good (WEF1) if $\frac{v_i(A_i)}{s_i}\ge\frac{v_i(A_j\diagdown{g})}{s_j}$ for every pair of agents $i,j\in N$ and some $g\in A_j$.</li>
</ul>
<p>(Chakraborty et al. 2021) proved that WEF1 allocations always exist and can be computed by a weight-dependent sequential picking algorithm that generalizes the Round-Robin algorithm.</p>
<p>Adapting MMS to the weighted setting (Not straightforward as WEF1):</p>
<ul>
<li>
<p>Underlying idea is to define a fairness ratio for each agent. Ideally when the items are divisible, the fairest partition for agent $i$ is such that $v_i(A_j)=s_j\cdot v_i(M)$ for all $j$. However since the items are indivisible, it's inevitable to induce some some degree of unfairness and the best fairness ratio for agent $i$ is:
  $$
  F_i=\max_{A\in\mathcal A_n(M)}\min_{j\in N}\left{\frac{v_i(A_j)}{s_j\cdot v_i(M)}\right}
  $$</p>
</li>
<li>
<p>An allocation $A$ is weighted maximin share fairness (WMMS) if $v_i(A_i)\ge\mu_i^n=F_i\cdot s_i\cdot v_i(M)$ for every agent $i\in N$. For any $\alpha\in[0,1]$, an allocation $A$ is $\alpha$-WMMS if $v_i(A_i)\ge\alpha\cdot\mu_i^n$ for every agent $i\in N$.</p>
</li>
</ul>
<p>$F_i\le1,\mu_i^n\le s_i\cdot v_i(N)$</p>
<ul>
<li>
<p>When agents are symmetric, WMMS is MMS.</p>
</li>
<li>
<p>(Farhadi et al. 2019) proved that with arbitrary entitlements, the best approximation ratio of WMMS is $1\over n$, which is somewhat surprisingly guaranteed by the Round-Robin algorithm.</p>
</li>
</ul>
<p>Some novel fairness notions highlight different perspectives of the weighted setting</p>
<ul>
<li>
<p><em>$l$-out-of-$d$ share</em></p>
</li>
<li>
<p><em>AnyPrice</em> (APS)</p>
</li>
</ul>
<p>Maximum value an agent can guarantee to herself if she has a budget equal to her entitlement and the goods are adversarially priced.</p>
<p>In unweighted setting, the APS value is at least as much as that of MMS, sometimes strictly larger.</p>
<p>(Babaioff et al. 2021) showed efficiently computing an allocation where every agents gets value no less than $3\over5$ of her APS.</p>
<p>(Aziz et al. 2020) considered weighted PROP1 and presented an algorithm for computing a weighted PROP1 and PO allocation for indivisible items.</p>
<h3 id="group-fairness">Group Fairness</h3>
<p>Focus on group-wisely fair.</p>
<p>For <strong>divisible</strong> items, (Berliant et al. 1992) defined the notion of <em>group envy-freeness</em> (GEF) by restricting envy-freeness to hold for groups of agents with equal size. (strictly stronger than requirement for EF)</p>
<p>(Conitzer et al. 2019) extended GEF for <strong>indivisible</strong> items, leading to the notion of group-fairness (GF), which take into account groups of different size.</p>
<p>An allocation is <strong>group-fair</strong> if for any non-empty subset of agent $S,T\subseteq N$ and every partition $(B_i)<em>{i\in S}$ of $\bigcup</em>{j\in T}A_j$, $((\frac{|S|}{|T|})\cdot v_i(B_i))<em>{i\in S}$ does not Pareto dominate $(v_i(A_i))</em>{i\in S}$.</p>
<p>When $|S|=|T|=1$ and $|S|=|T|=n$ imply the traditional requirements of EF and PO.</p>
<p>(Conitzer et al. 2019) and (Aziz and Rey 2020) introduced different variants of "up to one" relaxations of GEF/GF and proved existential and hardness results.</p>
<p>(Suksompong 2018) focused on a setting where each agent drives full value from all the goods allocated to the group she belongs to, and showed bounds on the best possible approximation of MMS.</p>
<p>(Kyropoulou et al. 2020) considered EF1 and EFX allocations in the same setting, as well as in settings with dynamic group formation.</p>
<h3 id="randomness-in-fair-division">Randomness in Fair Division</h3>
<p>Randomization can be used as a tool to circumvent impossibilities in the task of allocating indivisible resources.</p>
<h4 id="best-of-both-worlds">Best of Both Worlds</h4>
<p>Envy-freeness w.r.t. the expected values (<em>ex-ante</em> EF)</p>
<p>In Round-Robin, agents have an advantage over those who are ordered after them. To eliminate this unfair advantage, we consider a randomized version where the ordering of the agents is picked at random.</p>
<p>(Freeman et al. 2020) showed that this randomized Round-Robin guarantees ex-ante PROP but not ex-ante EF.</p>
<p>The Probabilistic-Serial (PS) algorithm (Bogomolnaia and Moulin 2001) is a randomized algorithm for allocating indivisible items in an ex-ante EF manner. Agents eat their most preferred good at a uniform rate and, once consumed, move on to the next available good. The algorithm terminates when all goods have been consumed.</p>
<p>(Freeman et al. 2020) presented a variant of this procedure, the recursive probabilistic serial algorithm that maintains the ex-ante EF property. Moreover every realized allocation is ex-post EF1.</p>
<p>(Aziz 2020) showed that the random allocation generated by the original probabilistic serial algorithm is equivalent to lottery over a set of EF1 allocations.</p>
<p>(Aziz and Brandl 2020) presented an eating algorithm that is suitable for any type of feasibility constraint and allocation problem with ordinal preferences.</p>
<p>(Caragiannis et al. 2021) studied <em>interim</em> envy-freeness, a notion which lies between ex-ante and ex-post envy-freeness.</p>
<h4 id="stochastic-settings">Stochastic Settings</h4>
<p>When the values are randomly drawn from some probability distributions, an envy-free allocation is likely to exist as long as the number of items is sufficiently large compared to the number of agents.</p>
<p>(Dickerson et al 2014) showed that when the values of the agents are independently drawn from an identical distribution, the social welfare maximizing allocation is EF with high probability when $m=\Omega(n\log n)$.</p>
<p>(Manurangsi and Suksompong 2020, 2021) improved the lower bound on the existence of envy-free allocations, and showed that the Round-Robin algorithm produces an envy-free allocation for a slightly lower $m$. (Bai and Gölz\ 2022) extended this result to the case of asymmetric distributions.</p>
<p>(Bai et al. 2022) showed that given a worst-case instance that does not admit any envy-free allocation, randomly perturbing the values of each agent leads to the existence of envy-free allocations with high probability.</p>
<h3 id="online-fair-division">Online Fair Division</h3>
<p>Online fair division consider settings where the agents or the goods arrive in an online manner.</p>
<p>$T$ items arrive online; when an item arrives, the values of the agents for it are realized and based on these we need to decide immediately and irrevocably how to allocate it, typically without knowing future events. (don't know how many items and value of these items)</p>
<p>Let $\text{Envy}<em>T$ be the cumulative envy until time $T$, i.e., the maximum difference between any agent's value for goods allocated to another agent and to herself in the first $T$ rounds. It is desired that the envy can vanish as time goes on $\lim</em>{T\rarr+\infty}\frac{\text{Envy}_T}{T}\rarr0$.</p>
<p>(Benade et al. 2018) proved that by allocating the new good to an agent chosen uniformly at random, $\text{Envy}_T=\tilde O(\sqrt\frac{T}{n})$, thus we can indeed eliminate the envy over time. They also showed that there exists a deterministic polynomial-time algorithm with the same envy bound as the random allocation algorithm, this bound is asymptotically optimal against an adaptive adversary meaning that the allocation is far from being EF1.</p>
<p>(He et al. 2019) relaxed the requirement of irrevocable decision by allowing the algorithm to reallocate previously allocated items. (If we reallocate all goods at each time i.e., $\Theta(T^2)$, we can surely achieve EF1. meaningless!) They showed that with 2 agents we actually only need $\Theta(T)$ allocations; for more than 2 agents, $O(T^\frac{3}{2})$ reallocation are sufficient and $\Omega(T)$ are necessary.</p>
<p>It remains to open question whether there exist competitive online algorithm for the computation of approximately MMS or Prop1/PropX allocations. For the case of identical valuation functions, approximate MMS allocation correspond to maximizing the minimum load on the job scheduling problem.</p>
<p>The alternative model that considers a fixed set of resources and agents who arrive or depart over time has not been considered for indivisible resources, partially because it is very challenging to achieve positive results.</p>
<h3 id="subsidies">Subsidies</h3>
<p>Consider the question of whether it is possible to pay the agents just a small amount of money on top of a given allocation in order to make it envy-free.</p>
<p>Allocations for which this can be done are called envy-freeable.</p>
<p>A pair $(A,p)$ consisting of an allocation $A$ and a payment profile $p=(p_1,\cdots,p_n)$ where $p_i\ge0$ for every $i$, is envy-free if $v_i(A_i)+p_i\ge v_i(A_j)+p_j$. An allocation $A$ is envy-freeable if there are payments $p$ s.t. $(A,p)$ is envy-free.</p>
<p>(Halpern and Shah 2019) noted that not all allocations are envy-freeable. $A$ is envy-freeable only if $A$ maximize the utilitarian welfare across all reassignments of its bundles to agents.</p>
<p>A natural question in this setting: Quantifying the minimum total amount of subsidy $\sum_ip_i$ required to find an envy-free allocation.</p>
<ul>
<li>(Halpern and Shah 2019) showed that if a fixed envy-freeable allocation is given, the minimum total subsidy can be computed in polynomial time. However, finding the envy-freeable allocation with overall minimum total subsidy is an NP-hard problem.</li>
<li>Deciding the existence of an envy-free allocation without any subsidy is NP-hard (Boveret and Lang 2008)</li>
<li>(Caragiannis and Ioannidis 2021) provided additive approximation guarantees and hardness results for computing an envy-freeable allocation that minimizes the total amount of subsidies.</li>
</ul>
<p>To bound the minimum subsidy required in the worst case over allocations,</p>
<ul>
<li>(Halpern and Shah 2019) proved that any envy-freeable allocation requires no more than $(n-1)m\cdot v^<em>$ total subsidy, where $v^</em>$ is the maximum value of an agent for a good.</li>
<li>If we are able to choose the allocations, the $n-1$ factor cannot be removed.</li>
</ul>
<h3 id="mixtures-of-indivisible-and-divisible-items">Mixtures of Indivisible and Divisible Items</h3>
<p>Scenarios involved both indivisible and divisible goods.</p>
<p>(Bei et al. 2021) proposed a new fairness notion called <em>envy-freeness for mixed goods</em> (EFM), which is a generalization of both EF and EF1 to the mixed goods setting.</p>
<p>Key idea behind EFM</p>
<ol>
<li>An agent $i$'s envy towards another agent $j$ vanishes if an indivisible good is removed from consideration when $j$ only gets indivisible goods,</li>
</ol>
<p>or</p>
<ol>
<li>Agent $i$ does not envy agent $j$ when $j$ gets some divisible goods.</li>
</ol>
<p>They proved that an EFM allocation always exists for any number of agents with additive valuations.</p>
<p>They examined the same setting and explored approximations of MMS.</p>
<p>(Bhaskar et al. 2021) showed that for a mixed resources model consisting of indivisible items and a divisible, undesireble heterogeneous resource, an EFM allocation always exists.</p>
<h3 id="chores-and-mixed-manna">Chores and Mixed Manna</h3>
<p>Consider similar questions when items can be seen as chores (can be negatively valued) or mixed manna (a mixture of both goods and chores)</p>
<p>The definition of EF, PROP and MMS remain the same. As in the case of goods, the existence of EF or PROP allocations is rarely guaranteeed.</p>
<ul>
<li>
<p>For additive valuations, (Aziz et al. 2017) proved that the Round-Robin algorithm returns a $2$-MMS allocation. Later improved to $4\over3$ and $11\over9$. On the negative side, (Feige et al. 2021) proved that no algorithm can ensure an approximation factor better than $44\over43$.</p>
</li>
<li>
<p>If the algorithm has access only to the ordinal preferences of agents, the best approximation of MMS can be guaranteed between $7\over5$ and $5\over3$ (Aziz et al. 2022).</p>
</li>
<li>
<p>When the valuations are submodular, (Li et al. 2022) proved that no algorithm guarantees a better than $n$-MMS allocation. (Aziz et al. 2019) considered the case when the agents have asymmetric entitlements and extended the notion of weighted MMS to chores, but the tight approximation ratio is still unknown.</p>
</li>
<li>
<p>Relaxations of EF and PROP need to be changed a bit to capture the fact that the agents have negative values for chores. Essentially, instead of removing goods from bundles of other agents to eliminate the envy of an agent, we nned to remove chores from the bundle of the agent her self.</p>
</li>
</ul>
<p>Definition for EF1 and EFX for chores: For chores, an allocation $A$ is $\alpha$-EF1 if $v_i(A_i\diagdown{g})\ge\alpha\cdot v_i(A_j)$ for any pair of agents $i,j$ and some $g\in A$; $A$ is $\alpha$-EFX if the inequality holds for any $g\in A$.</p>
<ul>
<li>
<p>For additive valuations, an EF1 allocation can be easily computed by Round-Robin algorithm.</p>
</li>
<li>
<p>(Bhaskar et al. 2021) noted that the allocation returned by Ency-Cycle Elimination algorithm may not be EF1 if the cycles are resolved arbitrarily. Instead, the top-trading technique must be used to preserve EF1.</p>
</li>
</ul>
<p>In contrast to the case of goods where EF1 and PO can be satisfied simultaneously, the compatibility of EF1 and PO is still unknown for chores.</p>
<ul>
<li>
<p>(Ebadian et al. 2022; Garg et al. 2022; Chaudhury et al. 2022) proved that for bi-valued instances, EF1+PO allocations always exist and can be found efficiently; this is the only known result so far.</p>
</li>
<li>
<p>The existence of EFX allocations for chores also remains open, with the only positive result being the computation of $O(n^2)$-EFX allocations due to (Zhou and Wu 2022).</p>
</li>
</ul>
<h3 id="other-settings">Other Settings</h3>
<p>Some allocations may not be feasible due to various restrictions, such as connectivity, cardinality, separation or budet constriants.</p>
<ul>
<li>(Suksompong 2021) discuss this part in detail.</li>
<li>(\Sheddighin et al. 2021) and (Aziz et al. 2021) studied externalities in fair division, where agents not only have value for what they get but also for what others get.</li>
<li>(Conitzer et al. 2017; Fain et al. 2018; Garg et al. 2021) related to public resource allocaation whre the items can be shared by the agents.</li>
</ul>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../../javascripts/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>